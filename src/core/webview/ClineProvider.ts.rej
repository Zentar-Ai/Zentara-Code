diff a/src/core/webview/ClineProvider.ts b/src/core/webview/ClineProvider.ts	(rejected hunks)
@@ -40,6 +40,7 @@ import {
 import { TelemetryService } from "@roo-code/telemetry"
 import { type CloudUserInfo, CloudService, ORGANIZATION_ALLOW_ALL, getRooCodeApiUrl } from "@roo-code/cloud"
 
+import { safeWriteJson } from "../../utils/safeWriteJson"
 import { Package } from "../../shared/package"
 import { findLast } from "../../shared/array"
 import { supportPrompt } from "../../shared/support-prompt"
@@ -117,12 +160,15 @@ export class ClineProvider
 	private taskEventListeners: WeakMap<Task, Array<() => void>> = new WeakMap()
 
 	private recentTasksCache?: string[]
+	private cloudService?: CloudService | null
 
 	public isViewLaunched = false
 	public settingsImportedAt?: number
 	public readonly latestAnnouncementId = "aug-20-2025-stealth-model" // Update for stealth model announcement
 	public readonly providerSettingsManager: ProviderSettingsManager
 	public readonly customModesManager: CustomModesManager
+	private updating_state = false
+	private stateUpdatePromiseResolve: ((value: unknown) => void) | null = null
 
 	constructor(
 		readonly context: vscode.ExtensionContext,
@@ -267,7 +309,8 @@ export class ClineProvider
 	 */
 	private async syncCloudProfiles() {
 		try {
-			const settings = CloudService.instance.getOrganizationSettings()
+			if (!this.cloudService) return
+			const settings = this.cloudService.getOrganizationSettings()
 			if (!settings?.providerProfiles) {
 				return
 			}
@@ -305,6 +348,7 @@ export class ClineProvider
 
 		// Add this cline instance into the stack that represents the order of all the called tasks.
 		this.clineStack.push(task)
+		this.registerTask(task) // Register in dictionary
 		task.emit(RooCodeEventName.TaskFocused)
 
 		// Perform special setup provider specific tasks.
@@ -348,6 +410,7 @@ export class ClineProvider
 
 		if (task) {
 			console.log(`[subtasks] removing task ${task.taskId}.${task.instanceId} from stack`)
+			this.unregisterTask(task.taskId) // Unregister from dictionary
 
 			try {
 				// Abort the running task and set isAbandoned to true so
@@ -375,6 +438,43 @@ export class ClineProvider
 		}
 	}
 
+	// New method: Remove Cline from Set
+	protected async removeClineFromSet(cline: Task | undefined) {
+		if (!cline) return
+
+		const taskId = cline.taskId // Store taskId before potential cleanup
+		console.log(`[SubAgentManager] removing specific task ${taskId}.${cline.instanceId} from set`)
+		this.clineSet.delete(cline)
+		this.unregisterTask(taskId) // Unregister from dictionary
+
+		// Don't remove from parallelTasksState here - let it be cleared all at once
+		// when all subagents complete in finishSubTask
+		// This keeps the subagent stack visible until the parent task resumes
+
+		try {
+			// Check if task is already being aborted to avoid double-abort
+			if (!cline.abort) {
+				await cline.abortTask(true)
+			} else {
+				console.log(`[SubAgentManager] task ${taskId} already aborted, skipping abortTask call`)
+			}
+		} catch (e) {
+			console.log(`[SubAgentManager] error aborting task ${taskId}: ${e}`)
+		}
+
+		// Make sure no reference kept, once promises end it will be
+		// garbage collected.
+		cline = undefined
+	}
+
+	// New method: Remove all tasks from Set
+	protected async removeAllClinesFromSet() {
+		console.log(`[SubAgentManager] removing all tasks from set`)
+		for (const cline of this.clineSet) {
+			await this.removeClineFromSet(cline)
+		}
+	}
+
 	// returns the current cline object in the stack (the top one)
 	// if the stack is empty, returns undefined
 	getCurrentTask(): Task | undefined {
@@ -393,15 +493,583 @@ export class ClineProvider
 		return this.clineStack.map((cline) => cline.taskId)
 	}
 
+	// Task Registry Methods for O(1) lookup
+
+	// Register task when created
+	private registerTask(task: Task): void {
+		this.taskRegistry.set(task.taskId, task)
+
+		// Store cleanup function reference for later removal
+		const cleanupHandler = () => {
+			this.unregisterTask(task.taskId)
+		}
+
+		// Listen for task disposal to clean up registry
+		task.once("disposed", cleanupHandler)
+
+		// Store handler reference for potential cleanup
+		this.taskCleanupHandlers.set(task.taskId, cleanupHandler)
+
+		// Listen for message events if this is a parallel task
+		if (task.isParallel) {
+			// Check for any existing ask messages that might have been created before registration
+			const existingAsk = task.clineMessages
+				.slice()
+				.reverse()
+				.find((msg) => msg.type === "ask" && !msg.partial)
+
+			if (existingAsk) {
+				// Handle existing ask message asynchronously
+				;(async () => {
+					const shouldAutoApprove = await this.shouldAutoApproveAsk(existingAsk)
+
+					if (shouldAutoApprove) {
+						// Auto-approve immediately without updating UI
+						let toolName = undefined
+						try {
+							toolName = existingAsk.text ? JSON.parse(existingAsk.text).tool : undefined
+						} catch (e) {
+							//console.error(`[AUTO_APPROVAL_DEBUG] Failed to parse tool for task ${task.taskId}:`, e)
+						}
+						raceLog("AUTO_APPROVING_EXISTING_SUBAGENT_TOOL", {
+							taskId: task.taskId,
+							askType: existingAsk.ask,
+							tool: toolName,
+						})
+
+						// Schedule auto-approval after a brief delay to ensure ask is properly set up
+						setTimeout(() => {
+							task.handleWebviewAskResponse("yesButtonClicked")
+						}, 50)
+					} else {
+						// Only update UI for tools that require manual approval
+
+						await this.updateSubagentAsk(task.taskId, existingAsk.ask, existingAsk.text)
+					}
+				})()
+			}
+
+			// Set up listener for future messages
+			task.on("message" as any, async ({ action, message }: { action: any; message: any }) => {
+				if ((action === "created" || action === "updated") && message.type === "ask") {
+					// Check if this specific ask (tool) should be auto-approved
+					const shouldAutoApprove = await this.shouldAutoApproveAsk(message)
+
+					if (shouldAutoApprove) {
+						// Auto-approve immediately without updating UI
+						let toolName = undefined
+						try {
+							toolName = message.text ? JSON.parse(message.text).tool : undefined
+						} catch (e) {
+							console.error(`[AUTO_APPROVAL_DEBUG] Failed to parse tool for task ${task.taskId}:`, e)
+						}
+						raceLog("AUTO_APPROVING_SUBAGENT_TOOL", {
+							taskId: task.taskId,
+							askType: message.ask,
+							tool: toolName,
+						})
+
+						// Update tool call for auto-approved tools
+						if (message.ask === "tool" && message.text) {
+							try {
+								const toolData = JSON.parse(message.text)
+
+								if (toolData && toolData.tool && !message.partial) {
+									this.updateSubagentToolCall(task.taskId, {
+										toolName: toolData.tool,
+										toolInput: toolData,
+										isPartial: message.partial,
+									}).catch(() => {})
+								}
+							} catch (e) {
+								console.error(
+									`[TOOL_DISPLAY_DEBUG] Auto-approval - Failed to parse tool for task ${task.taskId}:`,
+									e,
+								)
+							}
+						}
+						// Schedule auto-approval after a brief delay to ensure ask is properly set up
+						setTimeout(() => {
+							task.handleWebviewAskResponse("yesButtonClicked")
+						}, 50)
+					} else {
+						// Only update UI for tools that require manual approval
+
+						await this.updateSubagentAsk(task.taskId, message.ask, message.text)
+
+						// If this is a tool ask, also update the tool call
+						if (message.ask === "tool" && message.text) {
+							/* 							console.log(
+								`[TOOL_DISPLAY_DEBUG] Manual approval - Parsing tool from ask text for task ${task.taskId}:`,
+								message.text?.substring(0, 200),
+							) */
+							try {
+								const toolData = JSON.parse(message.text)
+								// console.log(
+								// 	`[TOOL_DISPLAY_DEBUG] Manual approval - Parsed tool data for task ${task.taskId}:`,
+								// 	{
+								// 		tool: toolData.tool,
+								// 		path: toolData.path,
+								// 		keys: Object.keys(toolData),
+								// 	},
+								// )
+								if (toolData && toolData.tool && !message.partial) {
+									await this.updateSubagentToolCall(task.taskId, {
+										toolName: toolData.tool,
+										toolInput: toolData,
+										isPartial: message.partial,
+									})
+								}
+							} catch (e) {
+								console.error(
+									`[TOOL_DISPLAY_DEBUG] Manual approval - Failed to parse tool for task ${task.taskId}:`,
+									e,
+								)
+							}
+						}
+					}
+				} else if (action === "created" && message.type === "say") {
+					// Clear ask state when task responds (but keep tool call)
+					await this.updateSubagentAsk(task.taskId, undefined, undefined)
+				}
+			})
+
+			// Also listen for ask response events
+			task.on("taskAskResponded" as any, async () => {
+				// Clear ask state when task receives a response
+				await this.updateSubagentAsk(task.taskId, undefined, undefined)
+			})
+		}
+
+		this.log(`[TaskRegistry] Registered task ${task.taskId}, total: ${this.taskRegistry.size}`)
+		raceLog("REGISTER_TASK", {
+			taskId: task.taskId,
+			isParallel: task.isParallel,
+			totalTasks: this.taskRegistry.size,
+			stackSize: this.clineStack.length,
+			setSize: this.clineSet.size,
+		})
+	}
+
+	// Unregister task when disposed
+	private unregisterTask(taskId: string): void {
+		this.taskRegistry.delete(taskId)
+
+		// Clean up event handler
+		const handler = this.taskCleanupHandlers.get(taskId)
+		if (handler) {
+			this.taskCleanupHandlers.delete(taskId)
+		}
+
+		// Also remove from ask set if present
+		this.removeFromAskSet(taskId)
+
+		this.log(`[TaskRegistry] Unregistered task ${taskId}, remaining tasks: ${this.taskRegistry.size}`)
+	}
+
+	// Find task by ID with O(1) lookup
+	findTaskById(taskId: string): Task | undefined {
+		return this.taskRegistry.get(taskId)
+	}
+
+	// Get all active tasks
+	getAllActiveTasks(): Task[] {
+		// Return all tasks from the registry
+		return Array.from(this.taskRegistry.values())
+	}
+
+	// Ask Queue Methods for sequential processing
+
+	// Add ask request to set for parallel processing
+	async addAskRequest(task: Task) {
+		raceLog("ADD_ASK_REQUEST_START", {
+			taskId: task.taskId,
+			askSetSize: this.askSet.size,
+			isProcessing: this.processingAsks.has(task.taskId),
+			existingAsks: Array.from(this.askSet.keys()),
+		})
+
+		// Prevent duplicate entries
+		if (this.askSet.has(task.taskId)) {
+			this.log(`Task ${task.taskId} already has pending ask`)
+			raceLog("ADD_ASK_REQUEST_DUPLICATE", { taskId: task.taskId })
+			return
+		}
+
+		// Add to ask set
+		this.askSet.set(task.taskId, { task, timestamp: Date.now() })
+
+		raceLog("ADD_ASK_REQUEST_ADDED", {
+			taskId: task.taskId,
+			newAskSetSize: this.askSet.size,
+			willProcess: !this.processingAsks.has(task.taskId),
+		})
+
+		// Process this specific ask immediately if not already processing it
+		if (!this.processingAsks.has(task.taskId)) {
+			// Process this ask in parallel with others
+			raceLog("ADD_ASK_REQUEST_WILL_PROCESS", { taskId: task.taskId })
+			// Random delay between 50-200ms to stagger ask processing
+			const randomDelay = Math.floor(Math.random() * 150) + 50
+			await delay(randomDelay)
+			this.processAsk(task.taskId)
+		} else {
+			raceLog("ADD_ASK_REQUEST_ALREADY_PROCESSING", { taskId: task.taskId })
+		}
+	}
+
+	// Process a specific ask in parallel with others
+	private async processAsk(taskId: string) {
+		// Check if already processing this task
+		if (this.processingAsks.has(taskId)) {
+			raceLog("PROCESS_ASK_ALREADY_PROCESSING", { taskId })
+			return
+		}
+
+		// Get ask info
+		const askInfo = this.askSet.get(taskId)
+		if (!askInfo) {
+			raceLog("PROCESS_ASK_NOT_FOUND", { taskId })
+			return
+		}
+
+		const { task, timestamp } = askInfo
+		const startTime = Date.now()
+
+		// Mark as processing
+		this.processingAsks.add(taskId)
+		raceLog("PROCESS_ASK_START", {
+			taskId,
+			askSetSize: this.askSet.size,
+			processingCount: this.processingAsks.size,
+		})
+
+		try {
+			// Check if task is still valid
+			if (!this.taskRegistry.has(taskId)) {
+				this.log(`Task ${taskId} no longer exists, removing from asks`)
+				this.askSet.delete(taskId)
+				return
+			}
+
+			// Log processing
+			this.log(`[AskSet] Processing ask for task ${taskId}, ${this.askSet.size} asks pending`)
+
+			// For parallel tasks, update only the subagent state
+			if (task.isParallel) {
+				// Find the ask message that needs approval
+				const askMessage = task.clineMessages
+					.slice()
+					.reverse()
+					.find((msg) => msg.type === "ask" && !msg.partial)
+
+				if (askMessage) {
+					// Check if this ask should be auto-approved
+					const shouldAutoApprove = await this.shouldAutoApproveAsk(askMessage)
+
+					if (shouldAutoApprove) {
+						console.log(`[AUTO_APPROVAL] Auto-approving ask for task ${taskId}`)
+						// Auto-approve without updating UI
+						task.handleWebviewAskResponse("yesButtonClicked")
+						// Remove from set since it's been handled
+						this.askSet.delete(taskId)
+						return
+					} else {
+						console.log(`[AUTO_APPROVAL] Showing UI for task ${taskId}`)
+						await this.updateSubagentAsk(taskId, askMessage.ask, askMessage.text)
+					}
+				}
+			} else {
+				// For non-parallel tasks, update the full state
+				await this.postStateToWebview(task)
+			}
+
+			// Note: We don't wait for response here since asks process in parallel
+			// The task's handleWebviewAskResponse will be called when user responds
+			// and we'll remove it from the set then
+
+			const processingTime = Date.now() - startTime
+			this.log(`[AskSet] Setup ask UI for task ${taskId} in ${processingTime}ms`)
+		} catch (error) {
+			this.log(`Error processing ask for task ${taskId}: ${error}`)
+			raceLog("PROCESS_ASK_ERROR", { taskId, error: String(error) })
+			// Remove from set on error
+			this.askSet.delete(taskId)
+		} finally {
+			// Remove from processing set
+			this.processingAsks.delete(taskId)
+			raceLog("PROCESS_ASK_COMPLETE", {
+				taskId,
+				askSetSize: this.askSet.size,
+				processingCount: this.processingAsks.size,
+			})
+		}
+	}
+
+	// Wait for task's ask to complete (response received or timeout)
+	private async waitForAskToComplete(task: Task): Promise<boolean> {
+		const checkInterval = 100
+		const maxWaitTime = 60 * 60 * 1000 // 60 minutes
+		const startTime = Date.now()
+		let isTimeout = false
+
+		// Wait until either:
+		// 1. Task receives a response (askResponse is set)
+		// 2. Task is no longer in the registry (disposed)
+		// 3. Timeout is reached
+		while (true) {
+			// Check if task was disposed
+			if (!this.taskRegistry.has(task.taskId)) {
+				this.log(`Task ${task.taskId} was disposed while waiting`)
+				break
+			}
+
+			// Check if task received response
+			if (task.hasAskResponse) {
+				break
+			} else {
+				this.log(`Task ${task.taskId} does not have response yet`)
+			}
+
+			// Check timeout
+			if (Date.now() - startTime > maxWaitTime) {
+				this.log(`Ask timeout for task ${task.taskId}`)
+				isTimeout = true
+				break
+			}
+
+			// Check if task is still waiting (has pending ask)
+			const hasPendingAsk = task.clineMessages.some(
+				(m) => m.type === "ask" && m.taskId === task.taskId && !task.hasAskResponse,
+			)
+
+			if (!hasPendingAsk) {
+				// Task no longer has a pending ask
+				break
+			}
+
+			await new Promise((resolve) => setTimeout(resolve, checkInterval))
+		}
+
+		return isTimeout
+	}
+
+	// Remove task from ask set (new parallel system)
+	removeFromAskSet(taskId: string) {
+		raceLog("REMOVE_FROM_ASK_SET_BEFORE", {
+			taskId,
+			askSetSize: this.askSet.size,
+			askSet: Array.from(this.askSet.keys()),
+		})
+
+		const removed = this.askSet.delete(taskId)
+
+		raceLog("REMOVE_FROM_ASK_SET_AFTER", {
+			taskId,
+			removed,
+			askSetSize: this.askSet.size,
+			askSet: Array.from(this.askSet.keys()),
+		})
+
+		// Also remove from processing set if present
+		this.processingAsks.delete(taskId)
+
+		return removed
+	}
+
+	// Monitoring and Diagnostics
+
+	// Ask processing metrics
+	private askMetrics = {
+		totalAsks: 0,
+		avgProcessingTime: 0,
+		maxProcessingTime: 0,
+		timeouts: 0,
+	}
+
+	// Log task registry state
+	public logTaskRegistry() {
+		this.log(`[TaskRegistry] Active tasks: ${this.taskRegistry.size}`)
+		this.log(`[TaskRegistry] Stack tasks: ${this.clineStack.length}`)
+		this.log(`[TaskRegistry] Set tasks: ${this.clineSet.size}`)
+		this.log(`[TaskRegistry] Ask set: ${this.askSet.size}`)
+
+		// Log detailed state for debugging
+		if (process.env.DEBUG_TASK_REGISTRY) {
+			for (const [taskId, task] of this.taskRegistry) {
+				const hasPendingAsk = task.clineMessages.some((m) => m.type === "ask" && !task.hasAskResponse)
+				this.log(`  Task ${taskId}: hasPendingAsk=${hasPendingAsk}`)
+			}
+		}
+	}
+
+	// Start periodic health check
+	private startHealthCheck() {
+		const healthCheckInterval = setInterval(() => {
+			// Check for orphaned tasks
+			for (const [taskId, task] of this.taskRegistry) {
+				if (!this.clineStack.includes(task) && !this.clineSet.has(task)) {
+					this.log(`[HealthCheck] WARNING: Orphaned task found: ${taskId}`)
+				}
+			}
+
+			// Check for stuck asks in Set
+			const now = Date.now()
+			for (const [taskId, item] of this.askSet) {
+				const waitTime = now - item.timestamp
+				if (waitTime > 60000) {
+					// 1 minute
+					this.log(`[HealthCheck] WARNING: Ask in Set pending for ${waitTime}ms: ${taskId}`)
+				}
+			}
+
+			// Log metrics periodically
+			if (this.askMetrics.totalAsks > 0) {
+				this.log(
+					`[AskMetrics] Total: ${this.askMetrics.totalAsks}, 
+					Avg: ${this.askMetrics.avgProcessingTime.toFixed(0)}ms, 
+					Max: ${this.askMetrics.maxProcessingTime}ms, 
+					Timeouts: ${this.askMetrics.timeouts} ,
+					number of tasks in clineSet: ${this.clineSet.size} ,
+					number of tasks in clineStack: ${this.clineStack.length} ,
+					number of tasks in taskRegistry: ${this.taskRegistry.size} ,
+					number of asks in askSet: ${this.askSet.size} ,
+					number of asks processing: ${this.processingAsks.size} ,
+					number of messages return from subagent so far: ${this.parallelTaskMessages.size}
+					`,
+				)
+			}
+		}, 30000) // Every 30 seconds
+
+		// Store interval for cleanup
+		this.disposables.push({
+			dispose: () => clearInterval(healthCheckInterval),
+		})
+	}
+
+	// Update ask metrics
+	private updateAskMetrics(processingTime: number, isTimeout: boolean) {
+		this.askMetrics.totalAsks++
+		if (isTimeout) {
+			this.askMetrics.timeouts++
+		}
+		this.askMetrics.maxProcessingTime = Math.max(this.askMetrics.maxProcessingTime, processingTime)
+		this.askMetrics.avgProcessingTime =
+			(this.askMetrics.avgProcessingTime * (this.askMetrics.totalAsks - 1) + processingTime) /
+			this.askMetrics.totalAsks
+	}
+
+	// Get current task metrics
+	public getTaskMetrics() {
+		return {
+			totalAsks: this.askMetrics.totalAsks,
+			avgProcessingTime: this.askMetrics.avgProcessingTime,
+			maxProcessingTime: this.askMetrics.maxProcessingTime,
+			timeouts: this.askMetrics.timeouts,
+		}
+	}
+
+	// Get current ask set status
+	public getAskSetStatus() {
+		// Get asks from Set
+		const askSetTasks = Array.from(this.askSet.entries()).map(([taskId, item]) => ({
+			taskId,
+			timestamp: item.timestamp,
+			waitTime: Date.now() - item.timestamp,
+			isProcessing: this.processingAsks.has(taskId),
+		}))
+
+		return {
+			// Set-based system
+			askSetSize: this.askSet.size,
+			processingCount: this.processingAsks.size,
+			askSetTasks,
+			totalPendingAsks: this.askSet.size,
+		}
+	}
+
+	public pauseAllStreamingExcept(taskToExclude?: Task) {
+		for (const task of this.taskRegistry.values()) {
+			if (taskToExclude && task.taskId === taskToExclude.taskId) {
+				continue
+			}
+			task.isStreamingPaused = true
+		}
+	}
+
+	public resumeAllStreaming() {
+		for (const task of this.taskRegistry.values()) {
+			task.isStreamingPaused = false
+		}
+	}
 	// remove the current task/cline instance (at the top of the stack), so this task is finished
 	// and resume the previous task/cline instance (if it exists)
 	// this is used when a sub task is finished and the parent task needs to be resumed
-	async finishSubTask(lastMessage: string) {
-		console.log(`[subtasks] finishing subtask ${lastMessage}`)
-		// remove the last cline instance from the stack (this is the finished sub task)
-		await this.removeClineFromStack()
-		// resume the last cline instance in the stack (if it exists - this is the 'parent' calling task)
-		await this.getCurrentTask()?.resumePausedTask(lastMessage)
+	async finishSubTask(lastMessage: string, cline: Task | undefined = undefined, cancelledByUser: boolean = false) {
+		console.log(`[subtasks] finishing subtask ${lastMessage} (cancelledByUser: ${cancelledByUser})`)
+
+		if (!cline) {
+			// Fallback to old behavior if no cline provided
+			await this.removeClineFromStack()
+			await this.getCurrentTask()?.resumePausedTask(lastMessage)
+			return
+		}
+
+		if (cline.isParallel) {
+			// For parallel tasks (subagents), store the message and remove from set
+			const parentTask = cline.parentTask
+			// Only store message if not cancelled (for cancelled tasks, we'll use a different message)
+			if (!cancelledByUser) {
+				this.parallelTaskMessages.set(cline.taskId, lastMessage)
+			}
+
+			// Update parallelTasks status to completed and clear streaming text
+			this.parallelTasksState = this.parallelTasksState.map((task) =>
+				task.taskId === cline.taskId
+					? { ...task, status: "completed" as const, streamingText: undefined }
+					: task,
+			)
+
+			// Send targeted update for parallelTasks only
+			await this.postMessageToWebview({
+				type: "parallelTasksUpdate",
+				payload: this.parallelTasksState,
+			})
+
+			await this.removeClineFromSet(cline)
+
+			// Only resume the parent task if all parallel tasks are finished (clineSet is empty)
+			if (this.clineSet.size === 0) {
+				let messageToParent: string
+
+				if (cancelledByUser) {
+					// If cancelled by user, send a special message to parent
+					messageToParent =
+						"All subagent tasks have been cancelled by user request. Please ask the user what to do next. Do not try to resume, repeat the task."
+				} else {
+					// Normal completion - concatenate all parallel task messages
+					messageToParent = Array.from(this.parallelTaskMessages.values()).join("\n\n")
+				}
+
+				// Clear the stored messages
+				this.parallelTaskMessages.clear()
+
+				// Clear parallelTasks from webview before resuming parent task
+				this.parallelTasksState = []
+				await this.postMessageToWebview({
+					type: "parallelTasksUpdate",
+					payload: [],
+				})
+
+				// Resume parent with the appropriate message
+				await parentTask?.resumePausedTask(messageToParent, false)
+			}
+		} else {
+			// For sequential tasks (new_task), remove from stack and resume current task
+			await this.removeClineFromStack()
+			// resume the last cline instance in the stack (if it exists - this is the 'parent' calling task)
+			await this.getCurrentTask()?.resumePausedTask(lastMessage, true)
+		}
 	}
 
 	// Clear the current task without treating it as a subtask
@@ -462,6 +1130,202 @@ export class ClineProvider
 		return this.recentTasksCache
 	}
 
+	// Update activity timestamp for a specific subagent
+	async updateSubagentActivity(taskId: string) {
+		// Update the activity timestamp for the specified task
+		this.parallelTasksState = this.parallelTasksState.map((task) =>
+			task.taskId === taskId ? { ...task, lastActivity: Date.now() } : task,
+		)
+
+		// Send targeted update for parallelTasks only
+		await this.postMessageToWebview({
+			type: "parallelTasksUpdate",
+			payload: this.parallelTasksState,
+		})
+	}
+
+	// Update ask state for a specific subagent
+	async updateSubagentAsk(taskId: string, askType?: string, askText?: string) {
+		// console.log(`[TOOL_DISPLAY_DEBUG] updateSubagentAsk called for task ${taskId} with:`, {
+		// 	askType,
+		// 	hasAskText: !!askText,
+		// 	askTextLength: askText?.length,
+		// })
+		// Update the ask state for the specified task
+		this.parallelTasksState = this.parallelTasksState.map((task) => {
+			if (task.taskId !== taskId) {
+				return task
+			}
+
+			// Keep existing tool call - it will be updated separately by updateSubagentToolCall
+			const updatedTask = {
+				...task,
+				askType,
+				askText,
+				streamingText: undefined,
+				lastActivity: Date.now(),
+			}
+			// console.log(
+			// 	`[TOOL_DISPLAY_DEBUG] Updated task ${taskId} ask state, toolCall preserved:`,
+			// 	updatedTask.toolCall,
+			// )
+			return updatedTask
+		})
+
+		// Send targeted update for parallelTasks only
+		await this.postMessageToWebview({
+			type: "parallelTasksUpdate",
+			payload: this.parallelTasksState,
+		})
+	}
+
+	// Update tool call for a specific subagent
+	async updateSubagentToolCall(
+		taskId: string,
+		toolCall: { toolName: string; toolInput: any; isPartial?: boolean } | undefined,
+	) {
+		//console.log(`[TOOL_DISPLAY_DEBUG] updateSubagentToolCall called for task ${taskId} with:`, toolCall)
+		this.parallelTasksState = this.parallelTasksState.map((task) => {
+			if (task.taskId !== taskId) {
+				return task
+			}
+			// Keep the tool call for display even after ask is cleared
+			const updatedTask = { ...task, toolCall, lastActivity: Date.now() }
+			//console.log(`[TOOL_DISPLAY_DEBUG] Updated task ${taskId} state with toolCall:`, updatedTask.toolCall)
+			return updatedTask
+		})
+
+		// Send targeted update for parallelTasks only
+		await this.postMessageToWebview({
+			type: "parallelTasksUpdate",
+			payload: this.parallelTasksState,
+		})
+	}
+
+	// Check if an ask should be auto-approved based on global settings
+	private async shouldAutoApproveAsk(askMessage: ClineMessage): Promise<boolean> {
+		const state = await this.getState()
+		const {
+			autoApprovalEnabled,
+			alwaysAllowReadOnly,
+			alwaysAllowReadOnlyOutsideWorkspace,
+			alwaysAllowWrite,
+			alwaysAllowWriteOutsideWorkspace,
+			alwaysAllowWriteProtected,
+			alwaysAllowExecute,
+			alwaysAllowBrowser,
+			alwaysAllowMcp,
+			alwaysAllowUpdateTodoList,
+			alwaysAllowModeSwitch,
+			alwaysAllowSubtasks,
+			alwaysAllowDebug,
+			alwaysAllowLsp,
+			allowedCommands,
+		} = state
+
+		// console.log(`[AUTO_APPROVAL_DEBUG] shouldAutoApproveAsk called with:`, {
+		// 	autoApprovalEnabled,
+		// 	askType: askMessage.ask,
+		// 	messageType: askMessage.type,
+		// 	alwaysAllowReadOnly,
+		// 	alwaysAllowReadOnlyOutsideWorkspace,
+		// })
+
+		if (!autoApprovalEnabled || askMessage.type !== "ask") {
+			return false
+		}
+
+		// Check different ask types
+		if (askMessage.ask === "browser_action_launch") {
+			return alwaysAllowBrowser ?? false
+		}
+
+		if (askMessage.ask === "command") {
+			if (!(alwaysAllowExecute ?? false)) {
+				return false
+			}
+			// Check if command is in allowed list
+			if (allowedCommands && allowedCommands.length > 0) {
+				const command = askMessage.text || ""
+				return allowedCommands.some((allowed: string) => command.startsWith(allowed))
+			}
+			return true
+		}
+
+		if (askMessage.ask === "tool") {
+			let tool: any = {}
+			try {
+				tool = JSON.parse(askMessage.text || "{}")
+			} catch (error) {
+				console.log(`[AUTO_APPROVAL_DEBUG] Failed to parse tool JSON:`, error)
+				return false
+			}
+
+			// Check for read-only tools
+			if (
+				tool.tool === "readFile" ||
+				tool.tool === "listFiles" ||
+				tool.tool === "listFilesTopLevel" ||
+				tool.tool === "listFilesRecursive" ||
+				tool.tool === "listCodeDefinitionNames" ||
+				tool.tool === "searchFiles" ||
+				tool.tool === "codebaseSearch" ||
+				tool.tool === "glob"
+			) {
+				const isOutsideWorkspace = !!tool.isOutsideWorkspace
+				const result =
+					(alwaysAllowReadOnly ?? false) &&
+					(!isOutsideWorkspace || (alwaysAllowReadOnlyOutsideWorkspace ?? false))
+
+				return result
+			}
+
+			// Check for write tools
+			if (
+				tool.tool === "writeToFile" ||
+				tool.tool === "editedExistingFile" ||
+				tool.tool === "newFileCreated" ||
+				tool.tool === "appliedDiff"
+			) {
+				const isOutsideWorkspace = !!tool.isOutsideWorkspace
+				const isProtected = askMessage.isProtected
+				return (
+					(alwaysAllowWrite ?? false) &&
+					(!isOutsideWorkspace || (alwaysAllowWriteOutsideWorkspace ?? false)) &&
+					(!isProtected || (alwaysAllowWriteProtected ?? false))
+				)
+			}
+
+			// Check for mode switch
+			if (tool.tool === "switchMode") {
+				return alwaysAllowModeSwitch ?? false
+			}
+
+			// Check for subtasks
+			if (tool.tool === "newTask" || tool.tool === "finishTask") {
+				return alwaysAllowSubtasks ?? false
+			}
+
+			// Auto-approve updateTodoList for all tasks (master and subagents)
+			// This is a safe internal operation that only updates task state
+			if (tool.tool === "updateTodoList") {
+				return alwaysAllowUpdateTodoList ?? false
+			}
+
+			// Check for debug tools
+			if (tool.tool === "debug") {
+				return alwaysAllowDebug ?? false
+			}
+
+			// Check for LSP tools
+			if (tool.tool === "lsp") {
+				return alwaysAllowLsp ?? false
+			}
+		}
+
+		return false
+	}
+
 	/*
 	VSCode extensions use the disposable pattern to clean up resources when the sidebar/editor tab is closed by the user or system. This applies to event listening, commands, interacting with the UI, etc.
 	- https://vscode-docs.readthedocs.io/en/stable/extensions/patterns-and-principles/
@@ -623,14 +1487,28 @@ export class ClineProvider
 		this.log("Resolving webview view")
 
 		this.view = webviewView
-		const inTabMode = "onDidChangeViewState" in webviewView
 
+		// Set panel reference according to webview type
+		const inTabMode = "onDidChangeViewState" in webviewView
 		if (inTabMode) {
 			setPanel(webviewView, "tab")
 		} else if ("onDidChangeVisibility" in webviewView) {
 			setPanel(webviewView, "sidebar")
 		}
 
+		// Initialize MCP Hub only once when webview is ready
+		if (!this.mcpHub) {
+			McpServerManager.getInstance(this.context, this)
+				.then((hub) => {
+					this.mcpHub = hub
+					this.mcpHub.registerClient()
+					this.log("MCP Hub initialized successfully after webview ready")
+				})
+				.catch((error) => {
+					this.log(`Failed to initialize MCP Hub: ${error}`)
+				})
+		}
+
 		// Initialize out-of-scope variables that need to receive persistent
 		// global state values.
 		this.getState().then(
@@ -765,7 +1643,18 @@ export class ClineProvider
 				| "initialTodos"
 			>
 		> = {},
+		is_parallel: boolean = false, // New parameter to indicate parallel execution
 	) {
+		raceLog("INIT_CLINE_WITH_TASK", {
+			hasTask: !!text,
+			hasImages: !!images,
+			parentTaskId: parentTask?.taskId,
+			is_parallel,
+			stackSize: this.clineStack.length,
+			setSize: this.clineSet.size,
+			task: text,
+		})
+
 		const {
 			apiConfiguration,
 			organizationAllowList,
@@ -794,19 +1683,27 @@ export class ClineProvider
 			rootTask: this.clineStack.length > 0 ? this.clineStack[0] : undefined,
 			parentTask,
 			taskNumber: this.clineStack.length + 1,
+			isParallel: is_parallel,
 			onCreated: this.taskCreationCallback,
 			enableTaskBridge: isRemoteControlEnabled(cloudUserInfo, remoteControlEnabled),
 			initialTodos: options.initialTodos,
 			...options,
 		})
-
-		await this.addClineToStack(task)
+		// If the task is parallel, add it to the set for parallel execution
+		if (is_parallel) {
+			raceLog("ADD_CLINE_TO_SET", { taskId: cline.taskId })
+			await this.addClineToSet(cline)
+		} else {
+			// Otherwise, add it to the stack for sequential execution
+			raceLog("ADD_CLINE_TO_STACK", { taskId: cline.taskId })
+			await this.addClineToStack(cline)
+		}
 
 		this.log(
-			`[subtasks] ${task.parentTask ? "child" : "parent"} task ${task.taskId}.${task.instanceId} instantiated`,
+			`[subtasks] ${cline.parentTask ? "child" : "parent"} task ${cline.taskId}.${cline.instanceId} instantiated`,
 		)
 
-		return task
+		return cline
 	}
 
 	public async createTaskWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {
@@ -1270,7 +2178,51 @@ export class ClineProvider
 
 	// Task Management
 
+	async clearAllPendingTasksAndAsks() {
+		console.log(`[SubAgentManager] Clearing all pending tasks and asks before starting new subagents`)
+
+		// Clear all running subagents
+		if (this.clineSet.size > 0) {
+			console.log(`[SubAgentManager] Disposing ${this.clineSet.size} remaining tasks from clineSet`)
+			for (const task of this.clineSet) {
+				try {
+					task.dispose() // Use dispose instead of abort for cleanup
+				} catch (error) {
+					console.error(`[SubAgentManager] Error disposing task ${task.taskId}:`, error)
+				}
+			}
+			this.clineSet.clear()
+		}
+
+		// Clear processing asks
+		if (this.processingAsks.size > 0) {
+			console.log(`[SubAgentManager] Clearing ${this.processingAsks.size} processing asks`)
+			this.processingAsks.clear()
+		}
+
+		// Clear parallel tasks state
+		this.parallelTasksState = []
+		await this.postMessageToWebview({
+			type: "parallelTasksUpdate",
+			payload: [],
+		})
+	}
+
 	async cancelTask() {
+		// Cancel all running subagents first
+		if (this.clineSet.size > 0) {
+			console.log(`[SubAgentManager] Cancelling all ${this.clineSet.size} running subagents.`)
+			for (const subagent of this.clineSet) {
+				await subagent.abortTask()
+			}
+			this.clineSet.clear()
+			this.parallelTasksState = []
+			await this.postMessageToWebview({
+				type: "parallelTasksUpdate",
+				payload: [],
+			})
+		}
+
 		const cline = this.getCurrentTask()
 
 		if (!cline) {
@@ -1313,6 +2271,114 @@ export class ClineProvider
 		await this.createTaskWithHistoryItem({ ...historyItem, rootTask, parentTask })
 	}
 
+	async cancelAllSubagentsAndResumeParent() {
+		console.log(`[CANCEL_SUBAGENT_DEBUG] ClineProvider: cancelAllSubagentsAndResumeParent called`)
+		console.log(`[CANCEL_SUBAGENT_DEBUG] ClineProvider: Current clineSet size: ${this.clineSet.size}`)
+		console.log(
+			`[CANCEL_SUBAGENT_DEBUG] ClineProvider: Current parallelTasksState length: ${this.parallelTasksState.length}`,
+		)
+		console.log(
+			`[CANCEL_SUBAGENT_DEBUG] ClineProvider: ClineSet contents:`,
+			Array.from(this.clineSet).map((c) => ({ taskId: c.taskId, instanceId: c.instanceId, abort: c.abort })),
+		)
+
+		console.log(`[SubAgentManager] Cancelling all subagents and resuming parent task`)
+
+		// Cancel all running subagents by calling finishSubTask for each
+		if (this.clineSet.size > 0) {
+			console.log(`[SubAgentManager] Cancelling ${this.clineSet.size} running subagents`)
+
+			// Create a copy of the set since finishSubTask will modify it
+			const subagentsArray = Array.from(this.clineSet)
+
+			// First, immediately mark all subagents as aborted to stop any ongoing operations
+			for (const subagent of subagentsArray) {
+				try {
+					console.log(
+						`[SubAgentManager] Setting abort flag for subagent ${subagent.taskId}.${subagent.instanceId}`,
+					)
+					// Set abort flag to stop any running operations immediately
+					subagent.abort = true
+					subagent.abandoned = true
+				} catch (e: any) {
+					console.error(
+						`[SubAgentManager] Error setting abort flag for subagent ${subagent.taskId}: ${e.message}`,
+					)
+				}
+			}
+
+			// Now finish each subagent cleanly - PARALLEL EXECUTION for better performance
+			const cleanupPromises = subagentsArray.map(async (subagent) => {
+				try {
+					console.log(
+						`[SubAgentManager] Finishing cancelled subagent ${subagent.taskId}.${subagent.instanceId}`,
+					)
+					// Call finishSubTask with empty message and cancelledByUser = true
+					// This will automatically handle:
+					// - NOT storing messages in parallelTaskMessages (since cancelled)
+					// - Updating parallelTasksState to completed
+					// - Removing from clineSet
+					// - Resuming parent with cancellation message when all are done
+					await this.finishSubTask("", subagent, true)
+					return { success: true, taskId: subagent.taskId }
+				} catch (e: any) {
+					console.error(
+						`[SubAgentManager] Error finishing cancelled subagent ${subagent.taskId}: ${e.message}`,
+					)
+					// Ensure subagent is removed from clineSet even if finishSubTask fails
+					try {
+						this.clineSet.delete(subagent)
+					} catch (cleanupError) {
+						console.error(`Failed to remove ${subagent.taskId} from clineSet:`, cleanupError)
+					}
+					return { success: false, taskId: subagent.taskId, error: e.message }
+				}
+			})
+
+			// Add timeout protection to prevent hanging cancellations
+			const CANCELLATION_TIMEOUT = 5000 // 5 seconds
+			const timeoutPromise = new Promise((_, reject) =>
+				setTimeout(() => reject(new Error("Cancellation timeout")), CANCELLATION_TIMEOUT),
+			)
+
+			try {
+				// Wait for all cleanups to complete in parallel with timeout protection
+				const results = await Promise.race([Promise.allSettled(cleanupPromises), timeoutPromise])
+
+				// Log summary of cleanup results
+				const successful = (results as PromiseSettledResult<any>[]).filter(
+					(r) => r.status === "fulfilled" && r.value.success,
+				).length
+				const failed = subagentsArray.length - successful
+				console.log(`[SubAgentManager] Cleanup summary: ${successful} successful, ${failed} failed`)
+			} catch (error) {
+				console.error(`[SubAgentManager] Cancellation timeout or error:`, error)
+				// Force cleanup even if timeout occurred
+				// Ensure clineSet is cleared and parent is resumed
+				const currentParentTask = subagentsArray[0]?.parentTask
+				subagentsArray.forEach((subagent) => {
+					try {
+						this.clineSet.delete(subagent)
+					} catch (e) {
+						console.error(`Force cleanup error for ${subagent.taskId}:`, e)
+					}
+				})
+
+				if (this.clineSet.size === 0) {
+					this.parallelTasksState = []
+					if (currentParentTask) {
+						await currentParentTask.resumePausedTask(
+							"All subagent tasks have been cancelled by user request (with timeout). Please ask the user what to do next. Do not try to resume, repeat the task.",
+							false,
+						)
+					}
+				}
+			}
+		} else {
+			console.log(`[SubAgentManager] No subagents to cancel`)
+		}
+	}
+
 	async updateCustomInstructions(instructions?: string) {
 		// User may be clearing the field.
 		await this.updateGlobalState("customInstructions", instructions || undefined)
@@ -1892,6 +3083,7 @@ export class ClineProvider
 			maxDiagnosticMessages: maxDiagnosticMessages ?? 50,
 			includeTaskHistoryInEnhance: includeTaskHistoryInEnhance ?? true,
 			remoteControlEnabled: remoteControlEnabled ?? false,
+			parallelTasks: this.parallelTasksState,
 		}
 	}
 
