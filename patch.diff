diff --git a/src/core/task/Task.ts b/src/core/task/Task.ts
index 5e96b6fb1..104cb8720 100644
--- a/src/core/task/Task.ts
+++ b/src/core/task/Task.ts
@@ -11,6 +11,7 @@ import { serializeError } from "serialize-error"
 
 import {
 	type TaskLike,
+	type TaskMetadata,
 	type TaskEvents,
 	type ProviderSettings,
 	type TokenUsage,
@@ -20,19 +21,21 @@ import {
 	type ClineMessage,
 	type ClineSay,
 	type ClineAsk,
-	type BlockingAsk,
 	type ToolProgressStatus,
 	type HistoryItem,
 	RooCodeEventName,
 	TelemetryEventName,
+	TaskStatus,
 	TodoItem,
+	DEFAULT_CONSECUTIVE_MISTAKE_LIMIT,
 	getApiProtocol,
 	getModelId,
-	DEFAULT_CONSECUTIVE_MISTAKE_LIMIT,
-	isBlockingAsk,
+	isIdleAsk,
+	isInteractiveAsk,
+	isResumableAsk,
 } from "@roo-code/types"
 import { TelemetryService } from "@roo-code/telemetry"
-import { CloudService } from "@roo-code/cloud"
+import { CloudService, ExtensionBridgeService } from "@roo-code/cloud"
 
 // api
 import { ApiHandler, ApiHandlerCreateMessageMetadata, buildApiHandler } from "../../api"
@@ -77,7 +80,7 @@ import { ToolRepetitionDetector } from "../tools/ToolRepetitionDetector"
 import { FileContextTracker } from "../context-tracking/FileContextTracker"
 import { RooIgnoreController } from "../ignore/RooIgnoreController"
 import { RooProtectedController } from "../protect/RooProtectedController"
-import { type AssistantMessageContent, presentAssistantMessage, parseAssistantMessage } from "../assistant-message"
+import { type AssistantMessageContent, presentAssistantMessage } from "../assistant-message"
 import { AssistantMessageParser } from "../assistant-message/AssistantMessageParser"
 import { truncateConversationIfNeeded } from "../sliding-window"
 import { ClineProvider } from "../webview/ClineProvider"
@@ -85,6 +88,7 @@ import { MultiSearchReplaceDiffStrategy } from "../diff/strategies/multi-search-
 import { MultiFileSearchReplaceDiffStrategy } from "../diff/strategies/multi-file-search-replace"
 import { readApiMessages, saveApiMessages, readTaskMessages, saveTaskMessages, taskMetadata } from "../task-persistence"
 import { getEnvironmentDetails } from "../environment/getEnvironmentDetails"
+import { checkContextWindowExceededError } from "../context/context-management/context-error-handling"
 import {
 	type CheckpointDiffOptions,
 	type CheckpointRestoreOptions,
@@ -101,12 +105,16 @@ import { restoreTodoListForTask } from "../tools/updateTodoListTool"
 import { AutoApprovalHandler } from "./AutoApprovalHandler"
 
 const MAX_EXPONENTIAL_BACKOFF_SECONDS = 600 // 10 minutes
+const DEFAULT_USAGE_COLLECTION_TIMEOUT_MS = 5000 // 5 seconds
+const FORCED_CONTEXT_REDUCTION_PERCENT = 75 // Keep 75% of context (remove 25%) on context window errors
+const MAX_CONTEXT_WINDOW_RETRIES = 3 // Maximum retries for context window errors
 
 export type TaskOptions = {
 	provider: ClineProvider
 	apiConfiguration: ProviderSettings
 	enableDiff?: boolean
 	enableCheckpoints?: boolean
+	enableTaskBridge?: boolean
 	fuzzyMatchThreshold?: number
 	consecutiveMistakeLimit?: number
 	task?: string
@@ -118,12 +126,15 @@ export type TaskOptions = {
 	parentTask?: Task
 	taskNumber?: number
 	onCreated?: (task: Task) => void
+	initialTodos?: TodoItem[]
 }
 
 export class Task extends EventEmitter<TaskEvents> implements TaskLike {
-	todoList?: TodoItem[]
 	readonly taskId: string
 	readonly instanceId: string
+	readonly metadata: TaskMetadata
+
+	todoList?: TodoItem[]
 
 	readonly rootTask: Task | undefined = undefined
 	readonly parentTask: Task | undefined = undefined
@@ -177,7 +188,12 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	providerRef: WeakRef<ClineProvider>
 	private readonly globalStoragePath: string
 	abort: boolean = false
-	blockingAsk?: BlockingAsk
+
+	// TaskStatus
+	idleAsk?: ClineMessage
+	resumableAsk?: ClineMessage
+	interactiveAsk?: ClineMessage
+
 	didFinishAbortingStream = false
 	abandoned = false
 	isInitialized = false
@@ -237,6 +253,10 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	checkpointService?: RepoPerTaskCheckpointService
 	checkpointServiceInitializing = false
 
+	// Task Bridge
+	enableTaskBridge: boolean
+	bridgeService: ExtensionBridgeService | null = null
+
 	// Streaming
 	isWaitingForFirstChunk = false
 	isStreaming = false
@@ -250,8 +270,7 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	didRejectTool = false
 	didAlreadyUseTool = false
 	didCompleteReadingStream = false
-	assistantMessageParser?: AssistantMessageParser
-	isAssistantMessageParserEnabled = false
+	assistantMessageParser: AssistantMessageParser
 	private lastUsedInstructions?: string
 	private skipPrevResponseIdOnce: boolean = false
 
@@ -260,6 +279,7 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		apiConfiguration,
 		enableDiff = false,
 		enableCheckpoints = true,
+		enableTaskBridge = false,
 		fuzzyMatchThreshold = 1.0,
 		consecutiveMistakeLimit = DEFAULT_CONSECUTIVE_MISTAKE_LIMIT,
 		task,
@@ -270,6 +290,7 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		parentTask,
 		taskNumber = -1,
 		onCreated,
+		initialTodos,
 	}: TaskOptions) {
 		super()
 
@@ -279,6 +300,11 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 
 		this.taskId = historyItem ? historyItem.id : crypto.randomUUID()
 
+		this.metadata = {
+			task: historyItem ? historyItem.task : task,
+			images: historyItem ? [] : images,
+		}
+
 		// Normal use-case is usually retry similar history task with new workspace.
 		this.workspacePath = parentTask
 			? parentTask.workspacePath
@@ -308,6 +334,7 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		this.globalStoragePath = provider.context.globalStorageUri.fsPath
 		this.diffViewProvider = new DiffViewProvider(this.cwd, this)
 		this.enableCheckpoints = enableCheckpoints
+		this.enableTaskBridge = enableTaskBridge
 
 		this.rootTask = rootTask
 		this.parentTask = parentTask
@@ -327,6 +354,9 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 			TelemetryService.instance.captureTaskCreated(this.taskId)
 		}
 
+		// Initialize the assistant message parser
+		this.assistantMessageParser = new AssistantMessageParser()
+
 		// Only set up diff strategy if diff is enabled.
 		if (this.diffEnabled) {
 			// Default to old strategy, will be updated if experiment is enabled.
@@ -347,6 +377,11 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 
 		this.toolRepetitionDetector = new ToolRepetitionDetector(this.consecutiveMistakeLimit)
 
+		// Initialize todo list if provided
+		if (initialTodos && initialTodos.length > 0) {
+			this.todoList = initialTodos
+		}
+
 		onCreated?.(this)
 
 		if (startTask) {
@@ -480,6 +515,7 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		if (this._taskMode === undefined) {
 			throw new Error("Task mode accessed before initialization. Use getTaskMode() or wait for taskModeReady.")
 		}
+
 		return this._taskMode
 	}
 
@@ -598,6 +634,16 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		}
 	}
 
+	private findMessageByTimestamp(ts: number): ClineMessage | undefined {
+		for (let i = this.clineMessages.length - 1; i >= 0; i--) {
+			if (this.clineMessages[i].ts === ts) {
+				return this.clineMessages[i]
+			}
+		}
+
+		return undefined
+	}
+
 	// Note that `partial` has three valid states true (partial message),
 	// false (completion of partial message), undefined (individual complete
 	// message).
@@ -696,16 +742,55 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 			await this.addToClineMessages({ ts: askTs, type: "ask", ask: type, text, isProtected })
 		}
 
-		// Detect if the task will enter an idle state.
-		const isReady = this.askResponse !== undefined || this.lastMessageTs !== askTs
-
-		if (!partial && !isReady && isBlockingAsk(type)) {
-			this.blockingAsk = type
-			this.emit(RooCodeEventName.TaskIdle, this.taskId)
+		// The state is mutable if the message is complete and the task will
+		// block (via the `pWaitFor`).
+		const isBlocking = !(this.askResponse !== undefined || this.lastMessageTs !== askTs)
+		const isStatusMutable = !partial && isBlocking
+		let statusMutationTimeouts: NodeJS.Timeout[] = []
+
+		if (isStatusMutable) {
+			if (isInteractiveAsk(type)) {
+				statusMutationTimeouts.push(
+					setTimeout(() => {
+						const message = this.findMessageByTimestamp(askTs)
+
+						if (message) {
+							this.interactiveAsk = message
+							this.emit(RooCodeEventName.TaskInteractive, this.taskId)
+						}
+					}, 1_000),
+				)
+			} else if (isResumableAsk(type)) {
+				statusMutationTimeouts.push(
+					setTimeout(() => {
+						const message = this.findMessageByTimestamp(askTs)
+
+						if (message) {
+							this.resumableAsk = message
+							this.emit(RooCodeEventName.TaskResumable, this.taskId)
+						}
+					}, 1_000),
+				)
+			} else if (isIdleAsk(type)) {
+				statusMutationTimeouts.push(
+					setTimeout(() => {
+						const message = this.findMessageByTimestamp(askTs)
+
+						if (message) {
+							this.idleAsk = message
+							this.emit(RooCodeEventName.TaskIdle, this.taskId)
+						}
+					}, 1_000),
+				)
+			}
 		}
 
-		console.log(`[Task#${this.taskId}] pWaitFor askResponse(${type}) -> blocking`)
+		console.log(
+			`[Task#${this.taskId}] pWaitFor askResponse(${type}) -> blocking (isStatusMutable = ${isStatusMutable}, statusMutationTimeouts = ${statusMutationTimeouts.length})`,
+		)
+
 		await pWaitFor(() => this.askResponse !== undefined || this.lastMessageTs !== askTs, { interval: 100 })
+
 		console.log(`[Task#${this.taskId}] pWaitFor askResponse(${type}) -> unblocked (${this.askResponse})`)
 
 		if (this.lastMessageTs !== askTs) {
@@ -720,9 +805,14 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		this.askResponseText = undefined
 		this.askResponseImages = undefined
 
+		// Cancel the timeouts if they are still running.
+		statusMutationTimeouts.forEach((timeout) => clearTimeout(timeout))
+
 		// Switch back to an active state.
-		if (this.blockingAsk) {
-			this.blockingAsk = undefined
+		if (this.idleAsk || this.resumableAsk || this.interactiveAsk) {
+			this.idleAsk = undefined
+			this.resumableAsk = undefined
+			this.interactiveAsk = undefined
 			this.emit(RooCodeEventName.TaskActive, this.taskId)
 		}
 
@@ -740,27 +830,30 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		this.askResponseImages = images
 	}
 
+	public approveAsk({ text, images }: { text?: string; images?: string[] } = {}) {
+		this.handleWebviewAskResponse("yesButtonClicked", text, images)
+	}
+
+	public denyAsk({ text, images }: { text?: string; images?: string[] } = {}) {
+		this.handleWebviewAskResponse("noButtonClicked", text, images)
+	}
+
 	public submitUserMessage(text: string, images?: string[]): void {
 		try {
-			const trimmed = (text ?? "").trim()
-			const imgs = images ?? []
+			text = (text ?? "").trim()
+			images = images ?? []
 
-			if (!trimmed && imgs.length === 0) {
+			if (text.length === 0 && images.length === 0) {
 				return
 			}
 
 			const provider = this.providerRef.deref()
-			if (!provider) {
+
+			if (provider) {
+				provider.postMessageToWebview({ type: "invoke", invoke: "sendMessage", text, images })
+			} else {
 				console.error("[Task#submitUserMessage] Provider reference lost")
-				return
 			}
-
-			void provider.postMessageToWebview({
-				type: "invoke",
-				invoke: "sendMessage",
-				text: trimmed,
-				images: imgs,
-			})
 		} catch (error) {
 			console.error("[Task#submitUserMessage] Failed to submit user message:", error)
 		}
@@ -972,6 +1065,20 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	// Start / Abort / Resume
 
 	private async startTask(task?: string, images?: string[]): Promise<void> {
+		if (this.enableTaskBridge) {
+			try {
+				this.bridgeService = this.bridgeService || ExtensionBridgeService.getInstance()
+
+				if (this.bridgeService) {
+					await this.bridgeService.subscribeToTask(this)
+				}
+			} catch (error) {
+				console.error(
+					`[Task#startTask] subscribeToTask failed - ${error instanceof Error ? error.message : String(error)}`,
+				)
+			}
+		}
+
 		// `conversationHistory` (for API) and `clineMessages` (for webview)
 		// need to be in sync.
 		// If the extension process were killed, then on restart the
@@ -980,6 +1087,10 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		// messages from previous session).
 		this.clineMessages = []
 		this.apiConversationHistory = []
+
+		// The todo list is already set in the constructor if initialTodos were provided
+		// No need to add any messages - the todoList property is already set
+
 		await this.providerRef.deref()?.postStateToWebview()
 
 		await this.say("text", task, images)
@@ -999,12 +1110,11 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	}
 
 	public async resumePausedTask(lastMessage: string) {
-		// Release this Cline instance from paused state.
 		this.isPaused = false
 		this.emit(RooCodeEventName.TaskUnpaused)
 
 		// Fake an answer from the subtask that it has completed running and
-		// this is the result of what it has done  add the message to the chat
+		// this is the result of what it has done add the message to the chat
 		// history and to the webview ui.
 		try {
 			await this.say("subtask_result", lastMessage)
@@ -1013,6 +1123,10 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 				role: "user",
 				content: [{ type: "text", text: `[new_task completed] Result: ${lastMessage}` }],
 			})
+
+			// Set skipPrevResponseIdOnce to ensure the next API call sends the full conversation
+			// including the subtask result, not just from before the subtask was created
+			this.skipPrevResponseIdOnce = true
 		} catch (error) {
 			this.providerRef
 				.deref()
@@ -1023,6 +1137,20 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	}
 
 	private async resumeTaskFromHistory() {
+		if (this.enableTaskBridge) {
+			try {
+				this.bridgeService = this.bridgeService || ExtensionBridgeService.getInstance()
+
+				if (this.bridgeService) {
+					await this.bridgeService.subscribeToTask(this)
+				}
+			} catch (error) {
+				console.error(
+					`[Task#resumeTaskFromHistory] subscribeToTask failed - ${error instanceof Error ? error.message : String(error)}`,
+				)
+			}
+		}
+
 		const modifiedClineMessages = await this.getSavedClineMessages()
 
 		// Remove any resume messages that may have been added before
@@ -1262,12 +1390,27 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	public dispose(): void {
 		console.log(`[Task] disposing task ${this.taskId}.${this.instanceId}`)
 
+		// Remove all event listeners to prevent memory leaks
+		try {
+			this.removeAllListeners()
+		} catch (error) {
+			console.error("Error removing event listeners:", error)
+		}
+
 		// Stop waiting for child task completion.
 		if (this.pauseInterval) {
 			clearInterval(this.pauseInterval)
 			this.pauseInterval = undefined
 		}
 
+		// Unsubscribe from TaskBridge service.
+		if (this.bridgeService) {
+			this.bridgeService
+				.unsubscribeFromTask(this.taskId)
+				.catch((error: unknown) => console.error("Error unsubscribing from task bridge:", error))
+			this.bridgeService = null
+		}
+
 		// Release any terminals associated with this task.
 		try {
 			// Release any terminals associated with this task.
@@ -1397,465 +1540,627 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 		userContent: Anthropic.Messages.ContentBlockParam[],
 		includeFileDetails: boolean = false,
 	): Promise<boolean> {
-		if (this.abort) {
-			throw new Error(`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`)
+		interface StackItem {
+			userContent: Anthropic.Messages.ContentBlockParam[]
+			includeFileDetails: boolean
 		}
 
-		if (this.consecutiveMistakeLimit > 0 && this.consecutiveMistakeCount >= this.consecutiveMistakeLimit) {
-			const { response, text, images } = await this.ask(
-				"mistake_limit_reached",
-				t("common:errors.mistake_limit_guidance"),
-			)
+		const stack: StackItem[] = [{ userContent, includeFileDetails }]
 
-			if (response === "messageResponse") {
-				userContent.push(
-					...[
-						{ type: "text" as const, text: formatResponse.tooManyMistakes(text) },
-						...formatResponse.imageBlocks(images),
-					],
-				)
+		while (stack.length > 0) {
+			const currentItem = stack.pop()!
+			const currentUserContent = currentItem.userContent
+			const currentIncludeFileDetails = currentItem.includeFileDetails
 
-				await this.say("user_feedback", text, images)
-
-				// Track consecutive mistake errors in telemetry.
-				TelemetryService.instance.captureConsecutiveMistakeError(this.taskId)
+			if (this.abort) {
+				throw new Error(`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`)
 			}
 
-			this.consecutiveMistakeCount = 0
-		}
-
-		// In this Cline request loop, we need to check if this task instance
-		// has been asked to wait for a subtask to finish before continuing.
-		const provider = this.providerRef.deref()
+			if (this.consecutiveMistakeLimit > 0 && this.consecutiveMistakeCount >= this.consecutiveMistakeLimit) {
+				const { response, text, images } = await this.ask(
+					"mistake_limit_reached",
+					t("common:errors.mistake_limit_guidance"),
+				)
 
-		if (this.isPaused && provider) {
-			provider.log(`[subtasks] paused ${this.taskId}.${this.instanceId}`)
-			await this.waitForResume()
-			provider.log(`[subtasks] resumed ${this.taskId}.${this.instanceId}`)
-			const currentMode = (await provider.getState())?.mode ?? defaultModeSlug
+				if (response === "messageResponse") {
+					currentUserContent.push(
+						...[
+							{ type: "text" as const, text: formatResponse.tooManyMistakes(text) },
+							...formatResponse.imageBlocks(images),
+						],
+					)
 
-			if (currentMode !== this.pausedModeSlug) {
-				// The mode has changed, we need to switch back to the paused mode.
-				await provider.handleModeSwitch(this.pausedModeSlug)
+					await this.say("user_feedback", text, images)
 
-				// Delay to allow mode change to take effect before next tool is executed.
-				await delay(500)
+					// Track consecutive mistake errors in telemetry.
+					TelemetryService.instance.captureConsecutiveMistakeError(this.taskId)
+				}
 
-				provider.log(
-					`[subtasks] task ${this.taskId}.${this.instanceId} has switched back to '${this.pausedModeSlug}' from '${currentMode}'`,
-				)
+				this.consecutiveMistakeCount = 0
 			}
-		}
 
-		// Getting verbose details is an expensive operation, it uses ripgrep to
-		// top-down build file structure of project which for large projects can
-		// take a few seconds. For the best UX we show a placeholder api_req_started
-		// message with a loading spinner as this happens.
+			// In this Cline request loop, we need to check if this task instance
+			// has been asked to wait for a subtask to finish before continuing.
+			const provider = this.providerRef.deref()
 
-		// Determine API protocol based on provider and model
-		const modelId = getModelId(this.apiConfiguration)
-		const apiProtocol = getApiProtocol(this.apiConfiguration.apiProvider, modelId)
+			if (this.isPaused && provider) {
+				provider.log(`[subtasks] paused ${this.taskId}.${this.instanceId}`)
+				await this.waitForResume()
+				provider.log(`[subtasks] resumed ${this.taskId}.${this.instanceId}`)
+				const currentMode = (await provider.getState())?.mode ?? defaultModeSlug
 
-		await this.say(
-			"api_req_started",
-			JSON.stringify({
-				request:
-					userContent.map((block) => formatContentBlockToMarkdown(block)).join("\n\n") + "\n\nLoading...",
-				apiProtocol,
-			}),
-		)
+				if (currentMode !== this.pausedModeSlug) {
+					// The mode has changed, we need to switch back to the paused mode.
+					await provider.handleModeSwitch(this.pausedModeSlug)
 
-		const {
-			showRooIgnoredFiles = true,
-			includeDiagnosticMessages = true,
-			maxDiagnosticMessages = 50,
-			maxReadFileLine = -1,
-		} = (await this.providerRef.deref()?.getState()) ?? {}
-
-		const parsedUserContent = await processUserContentMentions({
-			userContent,
-			cwd: this.cwd,
-			urlContentFetcher: this.urlContentFetcher,
-			fileContextTracker: this.fileContextTracker,
-			rooIgnoreController: this.rooIgnoreController,
-			showRooIgnoredFiles,
-			includeDiagnosticMessages,
-			maxDiagnosticMessages,
-			maxReadFileLine,
-		})
+					// Delay to allow mode change to take effect before next tool is executed.
+					await delay(500)
 
-		const environmentDetails = await getEnvironmentDetails(this, includeFileDetails)
+					provider.log(
+						`[subtasks] task ${this.taskId}.${this.instanceId} has switched back to '${this.pausedModeSlug}' from '${currentMode}'`,
+					)
+				}
+			}
 
-		// Add environment details as its own text block, separate from tool
-		// results.
-		const finalUserContent = [...parsedUserContent, { type: "text" as const, text: environmentDetails }]
+			// Getting verbose details is an expensive operation, it uses ripgrep to
+			// top-down build file structure of project which for large projects can
+			// take a few seconds. For the best UX we show a placeholder api_req_started
+			// message with a loading spinner as this happens.
+
+			// Determine API protocol based on provider and model
+			const modelId = getModelId(this.apiConfiguration)
+			const apiProtocol = getApiProtocol(this.apiConfiguration.apiProvider, modelId)
+
+			await this.say(
+				"api_req_started",
+				JSON.stringify({
+					request:
+						currentUserContent.map((block) => formatContentBlockToMarkdown(block)).join("\n\n") +
+						"\n\nLoading...",
+					apiProtocol,
+				}),
+			)
 
-		await this.addToApiConversationHistory({ role: "user", content: finalUserContent })
-		TelemetryService.instance.captureConversationMessage(this.taskId, "user")
+			const {
+				showRooIgnoredFiles = true,
+				includeDiagnosticMessages = true,
+				maxDiagnosticMessages = 50,
+				maxReadFileLine = -1,
+			} = (await this.providerRef.deref()?.getState()) ?? {}
+
+			const parsedUserContent = await processUserContentMentions({
+				userContent: currentUserContent,
+				cwd: this.cwd,
+				urlContentFetcher: this.urlContentFetcher,
+				fileContextTracker: this.fileContextTracker,
+				rooIgnoreController: this.rooIgnoreController,
+				showRooIgnoredFiles,
+				includeDiagnosticMessages,
+				maxDiagnosticMessages,
+				maxReadFileLine,
+			})
 
-		// Since we sent off a placeholder api_req_started message to update the
-		// webview while waiting to actually start the API request (to load
-		// potential details for example), we need to update the text of that
-		// message.
-		const lastApiReqIndex = findLastIndex(this.clineMessages, (m) => m.say === "api_req_started")
+			const environmentDetails = await getEnvironmentDetails(this, currentIncludeFileDetails)
 
-		this.clineMessages[lastApiReqIndex].text = JSON.stringify({
-			request: finalUserContent.map((block) => formatContentBlockToMarkdown(block)).join("\n\n"),
-			apiProtocol,
-		} satisfies ClineApiReqInfo)
+			// Add environment details as its own text block, separate from tool
+			// results.
+			const finalUserContent = [...parsedUserContent, { type: "text" as const, text: environmentDetails }]
 
-		await this.saveClineMessages()
-		await provider?.postStateToWebview()
+			await this.addToApiConversationHistory({ role: "user", content: finalUserContent })
+			TelemetryService.instance.captureConversationMessage(this.taskId, "user")
 
-		try {
-			let cacheWriteTokens = 0
-			let cacheReadTokens = 0
-			let inputTokens = 0
-			let outputTokens = 0
-			let totalCost: number | undefined
-
-			// We can't use `api_req_finished` anymore since it's a unique case
-			// where it could come after a streaming message (i.e. in the middle
-			// of being updated or executed).
-			// Fortunately `api_req_finished` was always parsed out for the GUI
-			// anyways, so it remains solely for legacy purposes to keep track
-			// of prices in tasks from history (it's worth removing a few months
-			// from now).
-			const updateApiReqMsg = (cancelReason?: ClineApiReqCancelReason, streamingFailedMessage?: string) => {
-				const existingData = JSON.parse(this.clineMessages[lastApiReqIndex].text || "{}")
-				this.clineMessages[lastApiReqIndex].text = JSON.stringify({
-					...existingData,
-					tokensIn: inputTokens,
-					tokensOut: outputTokens,
-					cacheWrites: cacheWriteTokens,
-					cacheReads: cacheReadTokens,
-					cost:
-						totalCost ??
-						calculateApiCostAnthropic(
-							this.api.getModel().info,
-							inputTokens,
-							outputTokens,
-							cacheWriteTokens,
-							cacheReadTokens,
-						),
-					cancelReason,
-					streamingFailedMessage,
-				} satisfies ClineApiReqInfo)
-			}
+			// Since we sent off a placeholder api_req_started message to update the
+			// webview while waiting to actually start the API request (to load
+			// potential details for example), we need to update the text of that
+			// message.
+			const lastApiReqIndex = findLastIndex(this.clineMessages, (m) => m.say === "api_req_started")
 
-			const abortStream = async (cancelReason: ClineApiReqCancelReason, streamingFailedMessage?: string) => {
-				if (this.diffViewProvider.isEditing) {
-					await this.diffViewProvider.revertChanges() // closes diff view
-				}
+			this.clineMessages[lastApiReqIndex].text = JSON.stringify({
+				request: finalUserContent.map((block) => formatContentBlockToMarkdown(block)).join("\n\n"),
+				apiProtocol,
+			} satisfies ClineApiReqInfo)
 
-				// if last message is a partial we need to update and save it
-				const lastMessage = this.clineMessages.at(-1)
+			await this.saveClineMessages()
+			await provider?.postStateToWebview()
 
-				if (lastMessage && lastMessage.partial) {
-					// lastMessage.ts = Date.now() DO NOT update ts since it is used as a key for virtuoso list
-					lastMessage.partial = false
-					// instead of streaming partialMessage events, we do a save and post like normal to persist to disk
-					console.log("updating partial message", lastMessage)
-					// await this.saveClineMessages()
+			try {
+				let cacheWriteTokens = 0
+				let cacheReadTokens = 0
+				let inputTokens = 0
+				let outputTokens = 0
+				let totalCost: number | undefined
+
+				// We can't use `api_req_finished` anymore since it's a unique case
+				// where it could come after a streaming message (i.e. in the middle
+				// of being updated or executed).
+				// Fortunately `api_req_finished` was always parsed out for the GUI
+				// anyways, so it remains solely for legacy purposes to keep track
+				// of prices in tasks from history (it's worth removing a few months
+				// from now).
+				const updateApiReqMsg = (cancelReason?: ClineApiReqCancelReason, streamingFailedMessage?: string) => {
+					if (lastApiReqIndex < 0 || !this.clineMessages[lastApiReqIndex]) {
+						return
+					}
+
+					const existingData = JSON.parse(this.clineMessages[lastApiReqIndex].text || "{}")
+					this.clineMessages[lastApiReqIndex].text = JSON.stringify({
+						...existingData,
+						tokensIn: inputTokens,
+						tokensOut: outputTokens,
+						cacheWrites: cacheWriteTokens,
+						cacheReads: cacheReadTokens,
+						cost:
+							totalCost ??
+							calculateApiCostAnthropic(
+								this.api.getModel().info,
+								inputTokens,
+								outputTokens,
+								cacheWriteTokens,
+								cacheReadTokens,
+							),
+						cancelReason,
+						streamingFailedMessage,
+					} satisfies ClineApiReqInfo)
 				}
 
-				// Let assistant know their response was interrupted for when task is resumed
-				await this.addToApiConversationHistory({
-					role: "assistant",
-					content: [
-						{
-							type: "text",
-							text:
-								assistantMessage +
-								`\n\n[${
-									cancelReason === "streaming_failed"
-										? "Response interrupted by API Error"
-										: "Response interrupted by user"
-								}]`,
-						},
-					],
-				})
+				const abortStream = async (cancelReason: ClineApiReqCancelReason, streamingFailedMessage?: string) => {
+					if (this.diffViewProvider.isEditing) {
+						await this.diffViewProvider.revertChanges() // closes diff view
+					}
 
-				// Update `api_req_started` to have cancelled and cost, so that
-				// we can display the cost of the partial stream.
-				updateApiReqMsg(cancelReason, streamingFailedMessage)
-				await this.saveClineMessages()
+					// if last message is a partial we need to update and save it
+					const lastMessage = this.clineMessages.at(-1)
 
-				// Signals to provider that it can retrieve the saved messages
-				// from disk, as abortTask can not be awaited on in nature.
-				this.didFinishAbortingStream = true
-			}
+					if (lastMessage && lastMessage.partial) {
+						// lastMessage.ts = Date.now() DO NOT update ts since it is used as a key for virtuoso list
+						lastMessage.partial = false
+						// instead of streaming partialMessage events, we do a save and post like normal to persist to disk
+						console.log("updating partial message", lastMessage)
+						// await this.saveClineMessages()
+					}
 
-			// Reset streaming state.
-			this.currentStreamingContentIndex = 0
-			this.currentStreamingDidCheckpoint = false
-			this.assistantMessageContent = []
-			this.didCompleteReadingStream = false
-			this.userMessageContent = []
-			this.userMessageContentReady = false
-			this.didRejectTool = false
-			this.didAlreadyUseTool = false
-			this.presentAssistantMessageLocked = false
-			this.presentAssistantMessageHasPendingUpdates = false
-			if (this.assistantMessageParser) {
-				this.assistantMessageParser.reset()
-			}
+					// Let assistant know their response was interrupted for when task is resumed
+					await this.addToApiConversationHistory({
+						role: "assistant",
+						content: [
+							{
+								type: "text",
+								text:
+									assistantMessage +
+									`\n\n[${
+										cancelReason === "streaming_failed"
+											? "Response interrupted by API Error"
+											: "Response interrupted by user"
+									}]`,
+							},
+						],
+					})
 
-			await this.diffViewProvider.reset()
+					// Update `api_req_started` to have cancelled and cost, so that
+					// we can display the cost of the partial stream.
+					updateApiReqMsg(cancelReason, streamingFailedMessage)
+					await this.saveClineMessages()
 
-			// Yields only if the first chunk is successful, otherwise will
-			// allow the user to retry the request (most likely due to rate
-			// limit error, which gets thrown on the first chunk).
-			const stream = this.attemptApiRequest()
-			let assistantMessage = ""
-			let reasoningMessage = ""
-			this.isStreaming = true
+					// Signals to provider that it can retrieve the saved messages
+					// from disk, as abortTask can not be awaited on in nature.
+					this.didFinishAbortingStream = true
+				}
 
-			try {
-				for await (const chunk of stream) {
-					if (!chunk) {
-						// Sometimes chunk is undefined, no idea that can cause
-						// it, but this workaround seems to fix it.
-						continue
-					}
+				// Reset streaming state.
+				this.currentStreamingContentIndex = 0
+				this.currentStreamingDidCheckpoint = false
+				this.assistantMessageContent = []
+				this.didCompleteReadingStream = false
+				this.userMessageContent = []
+				this.userMessageContentReady = false
+				this.didRejectTool = false
+				this.didAlreadyUseTool = false
+				this.presentAssistantMessageLocked = false
+				this.presentAssistantMessageHasPendingUpdates = false
+				this.assistantMessageParser.reset()
 
-					switch (chunk.type) {
-						case "reasoning":
-							reasoningMessage += chunk.text
-							await this.say("reasoning", reasoningMessage, undefined, true)
-							break
-						case "usage":
-							inputTokens += chunk.inputTokens
-							outputTokens += chunk.outputTokens
-							cacheWriteTokens += chunk.cacheWriteTokens ?? 0
-							cacheReadTokens += chunk.cacheReadTokens ?? 0
-							totalCost = chunk.totalCost
-							break
-						case "text": {
-							assistantMessage += chunk.text
+				await this.diffViewProvider.reset()
+
+				// Yields only if the first chunk is successful, otherwise will
+				// allow the user to retry the request (most likely due to rate
+				// limit error, which gets thrown on the first chunk).
+				const stream = this.attemptApiRequest()
+				let assistantMessage = ""
+				let reasoningMessage = ""
+				this.isStreaming = true
+
+				try {
+					const iterator = stream[Symbol.asyncIterator]()
+					let item = await iterator.next()
+					while (!item.done) {
+						const chunk = item.value
+						item = await iterator.next()
+						if (!chunk) {
+							// Sometimes chunk is undefined, no idea that can cause
+							// it, but this workaround seems to fix it.
+							continue
+						}
 
-							// Parse raw assistant message chunk into content blocks.
-							const prevLength = this.assistantMessageContent.length
-							if (this.isAssistantMessageParserEnabled && this.assistantMessageParser) {
+						switch (chunk.type) {
+							case "reasoning":
+								reasoningMessage += chunk.text
+								await this.say("reasoning", reasoningMessage, undefined, true)
+								break
+							case "usage":
+								inputTokens += chunk.inputTokens
+								outputTokens += chunk.outputTokens
+								cacheWriteTokens += chunk.cacheWriteTokens ?? 0
+								cacheReadTokens += chunk.cacheReadTokens ?? 0
+								totalCost = chunk.totalCost
+								break
+							case "text": {
+								assistantMessage += chunk.text
+
+								// Parse raw assistant message chunk into content blocks.
+								const prevLength = this.assistantMessageContent.length
 								this.assistantMessageContent = this.assistantMessageParser.processChunk(chunk.text)
-							} else {
-								// Use the old parsing method when experiment is disabled
-								this.assistantMessageContent = parseAssistantMessage(assistantMessage)
+
+								if (this.assistantMessageContent.length > prevLength) {
+									// New content we need to present, reset to
+									// false in case previous content set this to true.
+									this.userMessageContentReady = false
+								}
+
+								// Present content to user.
+								presentAssistantMessage(this)
+								break
 							}
+						}
 
-							if (this.assistantMessageContent.length > prevLength) {
-								// New content we need to present, reset to
-								// false in case previous content set this to true.
-								this.userMessageContentReady = false
+						if (this.abort) {
+							console.log(`aborting stream, this.abandoned = ${this.abandoned}`)
+
+							if (!this.abandoned) {
+								// Only need to gracefully abort if this instance
+								// isn't abandoned (sometimes OpenRouter stream
+								// hangs, in which case this would affect future
+								// instances of Cline).
+								await abortStream("user_cancelled")
 							}
 
-							// Present content to user.
-							presentAssistantMessage(this)
+							break // Aborts the stream.
+						}
+
+						if (this.didRejectTool) {
+							// `userContent` has a tool rejection, so interrupt the
+							// assistant's response to present the user's feedback.
+							assistantMessage += "\n\n[Response interrupted by user feedback]"
+							// Instead of setting this preemptively, we allow the
+							// present iterator to finish and set
+							// userMessageContentReady when its ready.
+							// this.userMessageContentReady = true
+							break
+						}
+
+						if (this.didAlreadyUseTool) {
+							assistantMessage +=
+								"\n\n[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]"
 							break
 						}
 					}
 
-					if (this.abort) {
-						console.log(`aborting stream, this.abandoned = ${this.abandoned}`)
+					// Create a copy of current token values to avoid race conditions
+					const currentTokens = {
+						input: inputTokens,
+						output: outputTokens,
+						cacheWrite: cacheWriteTokens,
+						cacheRead: cacheReadTokens,
+						total: totalCost,
+					}
 
-						if (!this.abandoned) {
-							// Only need to gracefully abort if this instance
-							// isn't abandoned (sometimes OpenRouter stream
-							// hangs, in which case this would affect future
-							// instances of Cline).
-							await abortStream("user_cancelled")
+					const drainStreamInBackgroundToFindAllUsage = async (apiReqIndex: number) => {
+						const timeoutMs = DEFAULT_USAGE_COLLECTION_TIMEOUT_MS
+						const startTime = Date.now()
+						const modelId = getModelId(this.apiConfiguration)
+
+						// Local variables to accumulate usage data without affecting the main flow
+						let bgInputTokens = currentTokens.input
+						let bgOutputTokens = currentTokens.output
+						let bgCacheWriteTokens = currentTokens.cacheWrite
+						let bgCacheReadTokens = currentTokens.cacheRead
+						let bgTotalCost = currentTokens.total
+
+						// Helper function to capture telemetry and update messages
+						const captureUsageData = async (
+							tokens: {
+								input: number
+								output: number
+								cacheWrite: number
+								cacheRead: number
+								total?: number
+							},
+							messageIndex: number = apiReqIndex,
+						) => {
+							if (
+								tokens.input > 0 ||
+								tokens.output > 0 ||
+								tokens.cacheWrite > 0 ||
+								tokens.cacheRead > 0
+							) {
+								// Update the shared variables atomically
+								inputTokens = tokens.input
+								outputTokens = tokens.output
+								cacheWriteTokens = tokens.cacheWrite
+								cacheReadTokens = tokens.cacheRead
+								totalCost = tokens.total
+
+								// Update the API request message with the latest usage data
+								updateApiReqMsg()
+								await this.saveClineMessages()
+
+								// Update the specific message in the webview
+								const apiReqMessage = this.clineMessages[messageIndex]
+								if (apiReqMessage) {
+									await this.updateClineMessage(apiReqMessage)
+								}
+
+								// Capture telemetry
+								TelemetryService.instance.captureLlmCompletion(this.taskId, {
+									inputTokens: tokens.input,
+									outputTokens: tokens.output,
+									cacheWriteTokens: tokens.cacheWrite,
+									cacheReadTokens: tokens.cacheRead,
+									cost:
+										tokens.total ??
+										calculateApiCostAnthropic(
+											this.api.getModel().info,
+											tokens.input,
+											tokens.output,
+											tokens.cacheWrite,
+											tokens.cacheRead,
+										),
+								})
+							}
 						}
 
-						break // Aborts the stream.
-					}
+						try {
+							// Continue processing the original stream from where the main loop left off
+							let usageFound = false
+							let chunkCount = 0
+
+							// Use the same iterator that the main loop was using
+							while (!item.done) {
+								// Check for timeout
+								if (Date.now() - startTime > timeoutMs) {
+									console.warn(
+										`[Background Usage Collection] Timed out after ${timeoutMs}ms for model: ${modelId}, processed ${chunkCount} chunks`,
+									)
+									// Clean up the iterator before breaking
+									if (iterator.return) {
+										await iterator.return(undefined)
+									}
+									break
+								}
+
+								const chunk = item.value
+								item = await iterator.next()
+								chunkCount++
+
+								if (chunk && chunk.type === "usage") {
+									usageFound = true
+									bgInputTokens += chunk.inputTokens
+									bgOutputTokens += chunk.outputTokens
+									bgCacheWriteTokens += chunk.cacheWriteTokens ?? 0
+									bgCacheReadTokens += chunk.cacheReadTokens ?? 0
+									bgTotalCost = chunk.totalCost
+								}
+							}
 
-					if (this.didRejectTool) {
-						// `userContent` has a tool rejection, so interrupt the
-						// assistant's response to present the user's feedback.
-						assistantMessage += "\n\n[Response interrupted by user feedback]"
-						// Instead of setting this preemptively, we allow the
-						// present iterator to finish and set
-						// userMessageContentReady when its ready.
-						// this.userMessageContentReady = true
-						break
+							if (
+								usageFound ||
+								bgInputTokens > 0 ||
+								bgOutputTokens > 0 ||
+								bgCacheWriteTokens > 0 ||
+								bgCacheReadTokens > 0
+							) {
+								// We have usage data either from a usage chunk or accumulated tokens
+								await captureUsageData(
+									{
+										input: bgInputTokens,
+										output: bgOutputTokens,
+										cacheWrite: bgCacheWriteTokens,
+										cacheRead: bgCacheReadTokens,
+										total: bgTotalCost,
+									},
+									lastApiReqIndex,
+								)
+							} else {
+								console.warn(
+									`[Background Usage Collection] Suspicious: request ${apiReqIndex} is complete, but no usage info was found. Model: ${modelId}`,
+								)
+							}
+						} catch (error) {
+							console.error("Error draining stream for usage data:", error)
+							// Still try to capture whatever usage data we have collected so far
+							if (
+								bgInputTokens > 0 ||
+								bgOutputTokens > 0 ||
+								bgCacheWriteTokens > 0 ||
+								bgCacheReadTokens > 0
+							) {
+								await captureUsageData(
+									{
+										input: bgInputTokens,
+										output: bgOutputTokens,
+										cacheWrite: bgCacheWriteTokens,
+										cacheRead: bgCacheReadTokens,
+										total: bgTotalCost,
+									},
+									lastApiReqIndex,
+								)
+							}
+						}
 					}
 
-					// PREV: We need to let the request finish for openrouter to
-					// get generation details.
-					// UPDATE: It's better UX to interrupt the request at the
-					// cost of the API cost not being retrieved.
-					if (this.didAlreadyUseTool) {
-						assistantMessage +=
-							"\n\n[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]"
-						break
-					}
-				}
-			} catch (error) {
-				// Abandoned happens when extension is no longer waiting for the
-				// Cline instance to finish aborting (error is thrown here when
-				// any function in the for loop throws due to this.abort).
-				if (!this.abandoned) {
-					// If the stream failed, there's various states the task
-					// could be in (i.e. could have streamed some tools the user
-					// may have executed), so we just resort to replicating a
-					// cancel task.
-
-					// Check if this was a user-initiated cancellation BEFORE calling abortTask
-					// If this.abort is already true, it means the user clicked cancel, so we should
-					// treat this as "user_cancelled" rather than "streaming_failed"
-					const cancelReason = this.abort ? "user_cancelled" : "streaming_failed"
-
-					const streamingFailedMessage = this.abort
-						? undefined
-						: (error.message ?? JSON.stringify(serializeError(error), null, 2))
-
-					// Now call abortTask after determining the cancel reason.
-					await this.abortTask()
-					await abortStream(cancelReason, streamingFailedMessage)
-
-					const history = await provider?.getTaskWithId(this.taskId)
-
-					if (history) {
-						await provider?.initClineWithHistoryItem(history.historyItem)
+					// Start the background task and handle any errors
+					drainStreamInBackgroundToFindAllUsage(lastApiReqIndex).catch((error) => {
+						console.error("Background usage collection failed:", error)
+					})
+				} catch (error) {
+					// Abandoned happens when extension is no longer waiting for the
+					// Cline instance to finish aborting (error is thrown here when
+					// any function in the for loop throws due to this.abort).
+					if (!this.abandoned) {
+						// If the stream failed, there's various states the task
+						// could be in (i.e. could have streamed some tools the user
+						// may have executed), so we just resort to replicating a
+						// cancel task.
+
+						// Check if this was a user-initiated cancellation BEFORE calling abortTask
+						// If this.abort is already true, it means the user clicked cancel, so we should
+						// treat this as "user_cancelled" rather than "streaming_failed"
+						const cancelReason = this.abort ? "user_cancelled" : "streaming_failed"
+
+						const streamingFailedMessage = this.abort
+							? undefined
+							: (error.message ?? JSON.stringify(serializeError(error), null, 2))
+
+						// Now call abortTask after determining the cancel reason.
+						await this.abortTask()
+						await abortStream(cancelReason, streamingFailedMessage)
+
+						const history = await provider?.getTaskWithId(this.taskId)
+
+						if (history) {
+							await provider?.createTaskWithHistoryItem(history.historyItem)
+						}
 					}
+				} finally {
+					this.isStreaming = false
 				}
-			} finally {
-				this.isStreaming = false
-			}
 
-			if (inputTokens > 0 || outputTokens > 0 || cacheWriteTokens > 0 || cacheReadTokens > 0) {
-				TelemetryService.instance.captureLlmCompletion(this.taskId, {
-					inputTokens,
-					outputTokens,
-					cacheWriteTokens,
-					cacheReadTokens,
-					cost:
-						totalCost ??
-						calculateApiCostAnthropic(
-							this.api.getModel().info,
-							inputTokens,
-							outputTokens,
-							cacheWriteTokens,
-							cacheReadTokens,
-						),
-				})
-			}
-
-			// Need to call here in case the stream was aborted.
-			if (this.abort || this.abandoned) {
-				throw new Error(`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`)
-			}
+				// Need to call here in case the stream was aborted.
+				if (this.abort || this.abandoned) {
+					throw new Error(
+						`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`,
+					)
+				}
 
-			this.didCompleteReadingStream = true
+				this.didCompleteReadingStream = true
 
-			// Set any blocks to be complete to allow `presentAssistantMessage`
-			// to finish and set `userMessageContentReady` to true.
-			// (Could be a text block that had no subsequent tool uses, or a
-			// text block at the very end, or an invalid tool use, etc. Whatever
-			// the case, `presentAssistantMessage` relies on these blocks either
-			// to be completed or the user to reject a block in order to proceed
-			// and eventually set userMessageContentReady to true.)
-			const partialBlocks = this.assistantMessageContent.filter((block) => block.partial)
-			partialBlocks.forEach((block) => (block.partial = false))
+				// Set any blocks to be complete to allow `presentAssistantMessage`
+				// to finish and set `userMessageContentReady` to true.
+				// (Could be a text block that had no subsequent tool uses, or a
+				// text block at the very end, or an invalid tool use, etc. Whatever
+				// the case, `presentAssistantMessage` relies on these blocks either
+				// to be completed or the user to reject a block in order to proceed
+				// and eventually set userMessageContentReady to true.)
+				const partialBlocks = this.assistantMessageContent.filter((block) => block.partial)
+				partialBlocks.forEach((block) => (block.partial = false))
 
-			// Can't just do this b/c a tool could be in the middle of executing.
-			// this.assistantMessageContent.forEach((e) => (e.partial = false))
+				// Can't just do this b/c a tool could be in the middle of executing.
+				// this.assistantMessageContent.forEach((e) => (e.partial = false))
 
-			// Now that the stream is complete, finalize any remaining partial content blocks
-			if (this.isAssistantMessageParserEnabled && this.assistantMessageParser) {
+				// Now that the stream is complete, finalize any remaining partial content blocks
 				this.assistantMessageParser.finalizeContentBlocks()
 				this.assistantMessageContent = this.assistantMessageParser.getContentBlocks()
-			}
-			// When using old parser, no finalization needed - parsing already happened during streaming
-
-			if (partialBlocks.length > 0) {
-				// If there is content to update then it will complete and
-				// update `this.userMessageContentReady` to true, which we
-				// `pWaitFor` before making the next request. All this is really
-				// doing is presenting the last partial message that we just set
-				// to complete.
-				presentAssistantMessage(this)
-			}
 
-			await this.persistGpt5Metadata(reasoningMessage)
+				if (partialBlocks.length > 0) {
+					// If there is content to update then it will complete and
+					// update `this.userMessageContentReady` to true, which we
+					// `pWaitFor` before making the next request. All this is really
+					// doing is presenting the last partial message that we just set
+					// to complete.
+					presentAssistantMessage(this)
+				}
 
-			updateApiReqMsg()
-			await this.saveClineMessages()
-			await this.providerRef.deref()?.postStateToWebview()
+				// Note: updateApiReqMsg() is now called from within drainStreamInBackgroundToFindAllUsage
+				// to ensure usage data is captured even when the stream is interrupted. The background task
+				// uses local variables to accumulate usage data before atomically updating the shared state.
+				await this.persistGpt5Metadata(reasoningMessage)
+				await this.saveClineMessages()
+				await this.providerRef.deref()?.postStateToWebview()
 
-			// Reset parser after each complete conversation round
-			if (this.assistantMessageParser) {
+				// Reset parser after each complete conversation round
 				this.assistantMessageParser.reset()
-			}
 
-			// Now add to apiConversationHistory.
-			// Need to save assistant responses to file before proceeding to
-			// tool use since user can exit at any moment and we wouldn't be
-			// able to save the assistant's response.
-			let didEndLoop = false
+				// Now add to apiConversationHistory.
+				// Need to save assistant responses to file before proceeding to
+				// tool use since user can exit at any moment and we wouldn't be
+				// able to save the assistant's response.
+				let didEndLoop = false
 
-			if (assistantMessage.length > 0) {
-				await this.addToApiConversationHistory({
-					role: "assistant",
-					content: [{ type: "text", text: assistantMessage }],
-				})
+				if (assistantMessage.length > 0) {
+					await this.addToApiConversationHistory({
+						role: "assistant",
+						content: [{ type: "text", text: assistantMessage }],
+					})
 
-				TelemetryService.instance.captureConversationMessage(this.taskId, "assistant")
-
-				// NOTE: This comment is here for future reference - this was a
-				// workaround for `userMessageContent` not getting set to true.
-				// It was due to it not recursively calling for partial blocks
-				// when `didRejectTool`, so it would get stuck waiting for a
-				// partial block to complete before it could continue.
-				// In case the content blocks finished it may be the api stream
-				// finished after the last parsed content block was executed, so
-				// we are able to detect out of bounds and set
-				// `userMessageContentReady` to true (note you should not call
-				// `presentAssistantMessage` since if the last block i
-				//  completed it will be presented again).
-				// const completeBlocks = this.assistantMessageContent.filter((block) => !block.partial) // If there are any partial blocks after the stream ended we can consider them invalid.
-				// if (this.currentStreamingContentIndex >= completeBlocks.length) {
-				// 	this.userMessageContentReady = true
-				// }
-
-				await pWaitFor(() => this.userMessageContentReady)
-
-				// If the model did not tool use, then we need to tell it to
-				// either use a tool or attempt_completion.
-				const didToolUse = this.assistantMessageContent.some((block) => block.type === "tool_use")
-
-				if (!didToolUse) {
-					this.userMessageContent.push({ type: "text", text: formatResponse.noToolsUsed() })
-					this.consecutiveMistakeCount++
-				}
+					TelemetryService.instance.captureConversationMessage(this.taskId, "assistant")
+
+					// NOTE: This comment is here for future reference - this was a
+					// workaround for `userMessageContent` not getting set to true.
+					// It was due to it not recursively calling for partial blocks
+					// when `didRejectTool`, so it would get stuck waiting for a
+					// partial block to complete before it could continue.
+					// In case the content blocks finished it may be the api stream
+					// finished after the last parsed content block was executed, so
+					// we are able to detect out of bounds and set
+					// `userMessageContentReady` to true (note you should not call
+					// `presentAssistantMessage` since if the last block i
+					//  completed it will be presented again).
+					// const completeBlocks = this.assistantMessageContent.filter((block) => !block.partial) // If there are any partial blocks after the stream ended we can consider them invalid.
+					// if (this.currentStreamingContentIndex >= completeBlocks.length) {
+					// 	this.userMessageContentReady = true
+					// }
+
+					await pWaitFor(() => this.userMessageContentReady)
+
+					// If the model did not tool use, then we need to tell it to
+					// either use a tool or attempt_completion.
+					const didToolUse = this.assistantMessageContent.some((block) => block.type === "tool_use")
+
+					if (!didToolUse) {
+						this.userMessageContent.push({ type: "text", text: formatResponse.noToolsUsed() })
+						this.consecutiveMistakeCount++
+					}
 
-				const recDidEndLoop = await this.recursivelyMakeClineRequests(this.userMessageContent)
-				didEndLoop = recDidEndLoop
-			} else {
-				// If there's no assistant_responses, that means we got no text
-				// or tool_use content blocks from API which we should assume is
-				// an error.
-				await this.say(
-					"error",
-					"Unexpected API Response: The language model did not provide any assistant messages. This may indicate an issue with the API or the model's output.",
-				)
+					if (this.userMessageContent.length > 0) {
+						stack.push({
+							userContent: [...this.userMessageContent], // Create a copy to avoid mutation issues
+							includeFileDetails: false, // Subsequent iterations don't need file details
+						})
 
-				await this.addToApiConversationHistory({
-					role: "assistant",
-					content: [{ type: "text", text: "Failure: I did not provide a response." }],
-				})
-			}
+						// Add periodic yielding to prevent blocking
+						await new Promise((resolve) => setImmediate(resolve))
+					}
+					// Continue to next iteration instead of setting didEndLoop from recursive call
+					continue
+				} else {
+					// If there's no assistant_responses, that means we got no text
+					// or tool_use content blocks from API which we should assume is
+					// an error.
+					await this.say(
+						"error",
+						"Unexpected API Response: The language model did not provide any assistant messages. This may indicate an issue with the API or the model's output.",
+					)
 
-			return didEndLoop // Will always be false for now.
-		} catch (error) {
-			// This should never happen since the only thing that can throw an
-			// error is the attemptApiRequest, which is wrapped in a try catch
-			// that sends an ask where if noButtonClicked, will clear current
-			// task and destroy this instance. However to avoid unhandled
-			// promise rejection, we will end this loop which will end execution
-			// of this instance (see `startTask`).
-			return true // Needs to be true so parent loop knows to end task.
+					await this.addToApiConversationHistory({
+						role: "assistant",
+						content: [{ type: "text", text: "Failure: I did not provide a response." }],
+					})
+				}
+
+				// If we reach here without continuing, return false (will always be false for now)
+				return false
+			} catch (error) {
+				// This should never happen since the only thing that can throw an
+				// error is the attemptApiRequest, which is wrapped in a try catch
+				// that sends an ask where if noButtonClicked, will clear current
+				// task and destroy this instance. However to avoid unhandled
+				// promise rejection, we will end this loop which will end execution
+				// of this instance (see `startTask`).
+				return true // Needs to be true so parent loop knows to end task.
+			}
 		}
+
+		// If we exit the while loop normally (stack is empty), return false
+		return false
 	}
 
 	private async getSystemPrompt(): Promise<string> {
@@ -1928,11 +2233,81 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 					maxConcurrentFileReads: maxConcurrentFileReads ?? 5,
 					todoListEnabled: apiConfiguration?.todoListEnabled ?? true,
 					useAgentRules: vscode.workspace.getConfiguration("roo-cline").get<boolean>("useAgentRules") ?? true,
+					newTaskRequireTodos: vscode.workspace
+						.getConfiguration("roo-cline")
+						.get<boolean>("newTaskRequireTodos", false),
 				},
+				undefined, // todoList
+				this.api.getModel().id,
 			)
 		})()
 	}
 
+	private getCurrentProfileId(state: any): string {
+		return (
+			state?.listApiConfigMeta?.find((profile: any) => profile.name === state?.currentApiConfigName)?.id ??
+			"default"
+		)
+	}
+
+	private async handleContextWindowExceededError(): Promise<void> {
+		const state = await this.providerRef.deref()?.getState()
+		const { profileThresholds = {} } = state ?? {}
+
+		const { contextTokens } = this.getTokenUsage()
+		const modelInfo = this.api.getModel().info
+		const maxTokens = getModelMaxOutputTokens({
+			modelId: this.api.getModel().id,
+			model: modelInfo,
+			settings: this.apiConfiguration,
+		})
+		const contextWindow = modelInfo.contextWindow
+
+		// Get the current profile ID using the helper method
+		const currentProfileId = this.getCurrentProfileId(state)
+
+		// Log the context window error for debugging
+		console.warn(
+			`[Task#${this.taskId}] Context window exceeded for model ${this.api.getModel().id}. ` +
+				`Current tokens: ${contextTokens}, Context window: ${contextWindow}. ` +
+				`Forcing truncation to ${FORCED_CONTEXT_REDUCTION_PERCENT}% of current context.`,
+		)
+
+		// Force aggressive truncation by keeping only 75% of the conversation history
+		const truncateResult = await truncateConversationIfNeeded({
+			messages: this.apiConversationHistory,
+			totalTokens: contextTokens || 0,
+			maxTokens,
+			contextWindow,
+			apiHandler: this.api,
+			autoCondenseContext: true,
+			autoCondenseContextPercent: FORCED_CONTEXT_REDUCTION_PERCENT,
+			systemPrompt: await this.getSystemPrompt(),
+			taskId: this.taskId,
+			profileThresholds,
+			currentProfileId,
+		})
+
+		if (truncateResult.messages !== this.apiConversationHistory) {
+			await this.overwriteApiConversationHistory(truncateResult.messages)
+		}
+
+		if (truncateResult.summary) {
+			const { summary, cost, prevContextTokens, newContextTokens = 0 } = truncateResult
+			const contextCondense: ContextCondense = { summary, cost, newContextTokens, prevContextTokens }
+			await this.say(
+				"condense_context",
+				undefined /* text */,
+				undefined /* images */,
+				false /* partial */,
+				undefined /* checkpoint */,
+				undefined /* progressStatus */,
+				{ isNonInteractive: true } /* options */,
+				contextCondense,
+			)
+		}
+	}
+
 	public async *attemptApiRequest(retryAttempt: number = 0): ApiStream {
 		const state = await this.providerRef.deref()?.getState()
 
@@ -2011,9 +2386,8 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 
 			const contextWindow = modelInfo.contextWindow
 
-			const currentProfileId =
-				state?.listApiConfigMeta.find((profile) => profile.name === state?.currentApiConfigName)?.id ??
-				"default"
+			// Get the current profile ID using the helper method
+			const currentProfileId = this.getCurrentProfileId(state)
 
 			const truncateResult = await truncateConversationIfNeeded({
 				messages: this.apiConversationHistory,
@@ -2120,6 +2494,21 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 			this.isWaitingForFirstChunk = false
 		} catch (error) {
 			this.isWaitingForFirstChunk = false
+			const isContextWindowExceededError = checkContextWindowExceededError(error)
+
+			// If it's a context window error and we haven't exceeded max retries for this error type
+			if (isContextWindowExceededError && retryAttempt < MAX_CONTEXT_WINDOW_RETRIES) {
+				console.warn(
+					`[Task#${this.taskId}] Context window exceeded for model ${this.api.getModel().id}. ` +
+						`Retry attempt ${retryAttempt + 1}/${MAX_CONTEXT_WINDOW_RETRIES}. ` +
+						`Attempting automatic truncation...`,
+				)
+				await this.handleContextWindowExceededError()
+				// Retry the request after handling the context window error
+				yield* this.attemptApiRequest(retryAttempt + 1)
+				return
+			}
+
 			// note that this api_req_failed ask is unique in that we only present this option if the api hasn't streamed any content yet (ie it fails on the first chunk due), as it would allow them to hit a retry button. However if the api failed mid-stream, it could be in any arbitrary state where some tools may have executed, so that error is handled differently and requires cancelling the task entirely.
 			if (autoApprovalEnabled && alwaysApproveResubmit) {
 				let errorMsg
@@ -2286,4 +2675,24 @@ export class Task extends EventEmitter<TaskEvents> implements TaskLike {
 	public get cwd() {
 		return this.workspacePath
 	}
+
+	public get taskStatus(): TaskStatus {
+		if (this.interactiveAsk) {
+			return TaskStatus.Interactive
+		}
+
+		if (this.resumableAsk) {
+			return TaskStatus.Resumable
+		}
+
+		if (this.idleAsk) {
+			return TaskStatus.Idle
+		}
+
+		return TaskStatus.Running
+	}
+
+	public get taskAsk(): ClineMessage | undefined {
+		return this.idleAsk || this.resumableAsk || this.interactiveAsk
+	}
 }
diff --git a/src/core/webview/ClineProvider.ts b/src/core/webview/ClineProvider.ts
index 274060a19..b6c00ee37 100644
--- a/src/core/webview/ClineProvider.ts
+++ b/src/core/webview/ClineProvider.ts
@@ -17,7 +17,11 @@ import {
 	type ProviderSettings,
 	type RooCodeSettings,
 	type ProviderSettingsEntry,
-	type ProviderSettingsWithId,
+	type StaticAppProperties,
+	type DynamicAppProperties,
+	type CloudAppProperties,
+	type TaskProperties,
+	type GitProperties,
 	type TelemetryProperties,
 	type TelemetryPropertiesProvider,
 	type CodeActionId,
@@ -25,17 +29,16 @@ import {
 	type TerminalActionId,
 	type TerminalActionPromptType,
 	type HistoryItem,
-	type CloudUserInfo,
+	type ClineAsk,
 	RooCodeEventName,
 	requestyDefaultModelId,
 	openRouterDefaultModelId,
 	glamaDefaultModelId,
-	ORGANIZATION_ALLOW_ALL,
 	DEFAULT_TERMINAL_OUTPUT_CHARACTER_LIMIT,
 	DEFAULT_WRITE_DELAY_MS,
 } from "@roo-code/types"
 import { TelemetryService } from "@roo-code/telemetry"
-import { CloudService, getRooCodeApiUrl } from "@roo-code/cloud"
+import { type CloudUserInfo, CloudService, ORGANIZATION_ALLOW_ALL, getRooCodeApiUrl } from "@roo-code/cloud"
 
 import { Package } from "../../shared/package"
 import { findLast } from "../../shared/array"
@@ -66,6 +69,7 @@ import { fileExistsAtPath } from "../../utils/fs"
 import { setTtsEnabled, setTtsSpeed } from "../../utils/tts"
 import { getWorkspaceGitInfo } from "../../utils/git"
 import { getWorkspacePath } from "../../utils/path"
+import { isRemoteControlEnabled } from "../../utils/remoteControl"
 
 import { setPanel } from "../../activate/registerCommands"
 
@@ -106,16 +110,17 @@ export class ClineProvider
 	private codeIndexStatusSubscription?: vscode.Disposable
 	private currentWorkspaceManager?: CodeIndexManager
 	private _workspaceTracker?: WorkspaceTracker // workSpaceTracker read-only for access outside this class
-	public get workspaceTracker(): WorkspaceTracker | undefined {
-		return this._workspaceTracker
-	}
 	protected mcpHub?: McpHub // Change from private to protected
 	private marketplaceManager: MarketplaceManager
 	private mdmService?: MdmService
+	private taskCreationCallback: (task: Task) => void
+	private taskEventListeners: WeakMap<Task, Array<() => void>> = new WeakMap()
+
+	private recentTasksCache?: string[]
 
 	public isViewLaunched = false
 	public settingsImportedAt?: number
-	public readonly latestAnnouncementId = "jul-29-2025-3-25-0" // Update for v3.25.0 announcement
+	public readonly latestAnnouncementId = "aug-20-2025-stealth-model" // Update for stealth model announcement
 	public readonly providerSettingsManager: ProviderSettingsManager
 	public readonly customModesManager: CustomModesManager
 
@@ -161,12 +166,72 @@ export class ClineProvider
 
 		this.marketplaceManager = new MarketplaceManager(this.context, this.customModesManager)
 
+		this.taskCreationCallback = (instance: Task) => {
+			this.emit(RooCodeEventName.TaskCreated, instance)
+
+			// Create named listener functions so we can remove them later.
+			const onTaskStarted = () => this.emit(RooCodeEventName.TaskStarted, instance.taskId)
+			const onTaskCompleted = (taskId: string, tokenUsage: any, toolUsage: any) =>
+				this.emit(RooCodeEventName.TaskCompleted, taskId, tokenUsage, toolUsage)
+			const onTaskAborted = () => this.emit(RooCodeEventName.TaskAborted, instance.taskId)
+			const onTaskFocused = () => this.emit(RooCodeEventName.TaskFocused, instance.taskId)
+			const onTaskUnfocused = () => this.emit(RooCodeEventName.TaskUnfocused, instance.taskId)
+			const onTaskActive = (taskId: string) => this.emit(RooCodeEventName.TaskActive, taskId)
+			const onTaskInteractive = (taskId: string) => this.emit(RooCodeEventName.TaskInteractive, taskId)
+			const onTaskResumable = (taskId: string) => this.emit(RooCodeEventName.TaskResumable, taskId)
+			const onTaskIdle = (taskId: string) => this.emit(RooCodeEventName.TaskIdle, taskId)
+
+			// Attach the listeners.
+			instance.on(RooCodeEventName.TaskStarted, onTaskStarted)
+			instance.on(RooCodeEventName.TaskCompleted, onTaskCompleted)
+			instance.on(RooCodeEventName.TaskAborted, onTaskAborted)
+			instance.on(RooCodeEventName.TaskFocused, onTaskFocused)
+			instance.on(RooCodeEventName.TaskUnfocused, onTaskUnfocused)
+			instance.on(RooCodeEventName.TaskActive, onTaskActive)
+			instance.on(RooCodeEventName.TaskInteractive, onTaskInteractive)
+			instance.on(RooCodeEventName.TaskResumable, onTaskResumable)
+			instance.on(RooCodeEventName.TaskIdle, onTaskIdle)
+
+			// Store the cleanup functions for later removal.
+			this.taskEventListeners.set(instance, [
+				() => instance.off(RooCodeEventName.TaskStarted, onTaskStarted),
+				() => instance.off(RooCodeEventName.TaskCompleted, onTaskCompleted),
+				() => instance.off(RooCodeEventName.TaskAborted, onTaskAborted),
+				() => instance.off(RooCodeEventName.TaskFocused, onTaskFocused),
+				() => instance.off(RooCodeEventName.TaskUnfocused, onTaskUnfocused),
+				() => instance.off(RooCodeEventName.TaskActive, onTaskActive),
+				() => instance.off(RooCodeEventName.TaskInteractive, onTaskInteractive),
+				() => instance.off(RooCodeEventName.TaskResumable, onTaskResumable),
+				() => instance.off(RooCodeEventName.TaskIdle, onTaskIdle),
+			])
+		}
+
 		// Initialize Roo Code Cloud profile sync.
 		this.initializeCloudProfileSync().catch((error) => {
 			this.log(`Failed to initialize cloud profile sync: ${error}`)
 		})
 	}
 
+	/**
+	 * Override EventEmitter's on method to match TaskProviderLike interface
+	 */
+	override on<K extends keyof TaskProviderEvents>(
+		event: K,
+		listener: (...args: TaskProviderEvents[K]) => void | Promise<void>,
+	): this {
+		return super.on(event, listener as any)
+	}
+
+	/**
+	 * Override EventEmitter's off method to match TaskProviderLike interface
+	 */
+	override off<K extends keyof TaskProviderEvents>(
+		event: K,
+		listener: (...args: TaskProviderEvents[K]) => void | Promise<void>,
+	): this {
+		return super.off(event, listener as any)
+	}
+
 	/**
 	 * Initialize cloud profile synchronization
 	 */
@@ -296,6 +361,14 @@ export class ClineProvider
 
 			task.emit(RooCodeEventName.TaskUnfocused)
 
+			// Remove event listeners before clearing the reference.
+			const cleanupFunctions = this.taskEventListeners.get(task)
+
+			if (cleanupFunctions) {
+				cleanupFunctions.forEach((cleanup) => cleanup())
+				this.taskEventListeners.delete(task)
+			}
+
 			// Make sure no reference kept, once promises end it will be
 			// garbage collected.
 			task = undefined
@@ -304,7 +377,7 @@ export class ClineProvider
 
 	// returns the current cline object in the stack (the top one)
 	// if the stack is empty, returns undefined
-	getCurrentCline(): Task | undefined {
+	getCurrentTask(): Task | undefined {
 		if (this.clineStack.length === 0) {
 			return undefined
 		}
@@ -312,7 +385,7 @@ export class ClineProvider
 	}
 
 	// returns the current clineStack length (how many cline objects are in the stack)
-	getClineStackSize(): number {
+	getTaskStackSize(): number {
 		return this.clineStack.length
 	}
 
@@ -328,7 +401,7 @@ export class ClineProvider
 		// remove the last cline instance from the stack (this is the finished sub task)
 		await this.removeClineFromStack()
 		// resume the last cline instance in the stack (if it exists - this is the 'parent' calling task)
-		await this.getCurrentCline()?.resumePausedTask(lastMessage)
+		await this.getCurrentTask()?.resumePausedTask(lastMessage)
 	}
 
 	// Clear the current task without treating it as a subtask
@@ -337,6 +410,58 @@ export class ClineProvider
 		await this.removeClineFromStack()
 	}
 
+	resumeTask(taskId: string): void {
+		// Use the existing showTaskWithId method which handles both current and historical tasks
+		this.showTaskWithId(taskId).catch((error) => {
+			this.log(`Failed to resume task ${taskId}: ${error.message}`)
+		})
+	}
+
+	getRecentTasks(): string[] {
+		if (this.recentTasksCache) {
+			return this.recentTasksCache
+		}
+
+		const history = this.getGlobalState("taskHistory") ?? []
+		const workspaceTasks: HistoryItem[] = []
+
+		for (const item of history) {
+			if (!item.ts || !item.task || item.workspace !== this.cwd) {
+				continue
+			}
+
+			workspaceTasks.push(item)
+		}
+
+		if (workspaceTasks.length === 0) {
+			this.recentTasksCache = []
+			return this.recentTasksCache
+		}
+
+		workspaceTasks.sort((a, b) => b.ts - a.ts)
+		let recentTaskIds: string[] = []
+
+		if (workspaceTasks.length >= 100) {
+			// If we have at least 100 tasks, return tasks from the last 7 days.
+			const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000
+
+			for (const item of workspaceTasks) {
+				// Stop when we hit tasks older than 7 days.
+				if (item.ts < sevenDaysAgo) {
+					break
+				}
+
+				recentTaskIds.push(item.id)
+			}
+		} else {
+			// Otherwise, return the most recent 100 tasks (or all if less than 100).
+			recentTaskIds = workspaceTasks.slice(0, Math.min(100, workspaceTasks.length)).map((item) => item.id)
+		}
+
+		this.recentTasksCache = recentTaskIds
+		return this.recentTasksCache
+	}
+
 	/*
 	VSCode extensions use the disposable pattern to clean up resources when the sidebar/editor tab is closed by the user or system. This applies to event listening, commands, interacting with the UI, etc.
 	- https://vscode-docs.readthedocs.io/en/stable/extensions/patterns-and-principles/
@@ -427,7 +552,7 @@ export class ClineProvider
 		}
 
 		// Check if there is a cline instance in the stack (if this provider has an active task)
-		if (visibleProvider.getCurrentCline()) {
+		if (visibleProvider.getCurrentTask()) {
 			return true
 		}
 
@@ -458,7 +583,7 @@ export class ClineProvider
 			return
 		}
 
-		await visibleProvider.initClineWithTask(prompt)
+		await visibleProvider.createTask(prompt)
 	}
 
 	public static async handleTerminalAction(
@@ -483,7 +608,7 @@ export class ClineProvider
 		}
 
 		try {
-			await visibleProvider.initClineWithTask(prompt)
+			await visibleProvider.createTask(prompt)
 		} catch (error) {
 			if (error instanceof OrganizationAllowListViolationError) {
 				// Errors from terminal commands seem to get swallowed / ignored.
@@ -498,18 +623,16 @@ export class ClineProvider
 		this.log("Resolving webview view")
 
 		this.view = webviewView
-
-		// Set panel reference according to webview type
 		const inTabMode = "onDidChangeViewState" in webviewView
+
 		if (inTabMode) {
-			// Tag page type
 			setPanel(webviewView, "tab")
 		} else if ("onDidChangeVisibility" in webviewView) {
-			// Sidebar Type
 			setPanel(webviewView, "sidebar")
 		}
 
-		// Initialize out-of-scope variables that need to receive persistent global state values
+		// Initialize out-of-scope variables that need to receive persistent
+		// global state values.
 		this.getState().then(
 			({
 				terminalShellIntegrationTimeout = Terminal.defaultShellIntegrationTimeout,
@@ -532,18 +655,15 @@ export class ClineProvider
 			},
 		)
 
-		// Initialize tts enabled state
 		this.getState().then(({ ttsEnabled }) => {
 			setTtsEnabled(ttsEnabled ?? false)
 		})
 
-		// Initialize tts speed state
 		this.getState().then(({ ttsSpeed }) => {
 			setTtsSpeed(ttsSpeed ?? 1)
 		})
 
 		webviewView.webview.options = {
-			// Allow scripts in the webview
 			enableScripts: true,
 			localResourceRoots: [this.contextProxy.extensionUri],
 		}
@@ -554,32 +674,31 @@ export class ClineProvider
 				: this.getHtmlContent(webviewView.webview)
 
 		// Sets up an event listener to listen for messages passed from the webview view context
-		// and executes code based on the message that is received
+		// and executes code based on the message that is received.
 		this.setWebviewMessageListener(webviewView.webview)
 
-		// Initialize code index status subscription for the current workspace
+		// Initialize code index status subscription for the current workspace.
 		this.updateCodeIndexStatusSubscription()
 
-		// Listen for active editor changes to update code index status for the current workspace
+		// Listen for active editor changes to update code index status for the
+		// current workspace.
 		const activeEditorSubscription = vscode.window.onDidChangeActiveTextEditor(() => {
-			// Update subscription when workspace might have changed
+			// Update subscription when workspace might have changed.
 			this.updateCodeIndexStatusSubscription()
 		})
 		this.webviewDisposables.push(activeEditorSubscription)
 
-		// Logs show up in bottom panel > Debug Console
-		//console.log("registering listener")
-
-		// Listen for when the panel becomes visible
+		// Listen for when the panel becomes visible.
 		// https://github.com/microsoft/vscode-discussions/discussions/840
 		if ("onDidChangeViewState" in webviewView) {
-			// WebviewView and WebviewPanel have all the same properties except for this visibility listener
-			// panel
+			// WebviewView and WebviewPanel have all the same properties except
+			// for this visibility listener panel.
 			const viewStateDisposable = webviewView.onDidChangeViewState(() => {
 				if (this.view?.visible) {
 					this.postMessageToWebview({ type: "action", action: "didBecomeVisible" })
 				}
 			})
+
 			this.webviewDisposables.push(viewStateDisposable)
 		} else if ("onDidChangeVisibility" in webviewView) {
 			// sidebar
@@ -588,6 +707,7 @@ export class ClineProvider
 					this.postMessageToWebview({ type: "action", action: "didBecomeVisible" })
 				}
 			})
+
 			this.webviewDisposables.push(visibilityDisposable)
 		}
 
@@ -624,24 +744,25 @@ export class ClineProvider
 		this.log("Webview view resolved")
 	}
 
-	public async initClineWithSubTask(parent: Task, task?: string, images?: string[]) {
-		return this.initClineWithTask(task, images, parent)
-	}
-
 	// When initializing a new task, (not from history but from a tool command
 	// new_task) there is no need to remove the previous task since the new
 	// task is a subtask of the previous one, and when it finishes it is removed
 	// from the stack and the caller is resumed in this way we can have a chain
 	// of tasks, each one being a sub task of the previous one until the main
 	// task is finished.
-	public async initClineWithTask(
+	public async createTask(
 		text?: string,
 		images?: string[],
 		parentTask?: Task,
 		options: Partial<
 			Pick<
 				TaskOptions,
-				"enableDiff" | "enableCheckpoints" | "fuzzyMatchThreshold" | "consecutiveMistakeLimit" | "experiments"
+				| "enableDiff"
+				| "enableCheckpoints"
+				| "fuzzyMatchThreshold"
+				| "consecutiveMistakeLimit"
+				| "experiments"
+				| "initialTodos"
 			>
 		> = {},
 	) {
@@ -652,6 +773,8 @@ export class ClineProvider
 			enableCheckpoints,
 			fuzzyMatchThreshold,
 			experiments,
+			cloudUserInfo,
+			remoteControlEnabled,
 		} = await this.getState()
 
 		if (!ProfileValidator.isProfileAllowed(apiConfiguration, organizationAllowList)) {
@@ -671,7 +794,9 @@ export class ClineProvider
 			rootTask: this.clineStack.length > 0 ? this.clineStack[0] : undefined,
 			parentTask,
 			taskNumber: this.clineStack.length + 1,
-			onCreated: (instance) => this.emit(RooCodeEventName.TaskCreated, instance),
+			onCreated: this.taskCreationCallback,
+			enableTaskBridge: isRemoteControlEnabled(cloudUserInfo, remoteControlEnabled),
+			initialTodos: options.initialTodos,
 			...options,
 		})
 
@@ -684,7 +809,7 @@ export class ClineProvider
 		return task
 	}
 
-	public async initClineWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {
+	public async createTaskWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {
 		await this.removeClineFromStack()
 
 		// If the history item has a saved mode, restore it and its associated API configuration
@@ -736,8 +861,13 @@ export class ClineProvider
 			enableCheckpoints,
 			fuzzyMatchThreshold,
 			experiments,
+			cloudUserInfo,
+			remoteControlEnabled,
 		} = await this.getState()
 
+		// Determine if TaskBridge should be enabled
+		const enableTaskBridge = isRemoteControlEnabled(cloudUserInfo, remoteControlEnabled)
+
 		const task = new Task({
 			provider: this,
 			apiConfiguration,
@@ -750,7 +880,8 @@ export class ClineProvider
 			rootTask: historyItem.rootTask,
 			parentTask: historyItem.parentTask,
 			taskNumber: historyItem.number,
-			onCreated: (instance) => this.emit(RooCodeEventName.TaskCreated, instance),
+			onCreated: this.taskCreationCallback,
+			enableTaskBridge,
 		})
 
 		await this.addClineToStack(task)
@@ -767,8 +898,8 @@ export class ClineProvider
 	}
 
 	private async getHMRHtmlContent(webview: vscode.Webview): Promise<string> {
-		// Try to read the port from the file
-		let localPort = "5173" // Default fallback
+		let localPort = "5173"
+
 		try {
 			const fs = require("fs")
 			const path = require("path")
@@ -784,7 +915,6 @@ export class ClineProvider
 			}
 		} catch (err) {
 			console.error("[ClineProvider:Vite] Failed to read Vite port file:", err)
-			// Continue with default port if file reading fails
 		}
 
 		const localServerUrl = `localhost:${localPort}`
@@ -794,7 +924,6 @@ export class ClineProvider
 			await axios.get(`http://${localServerUrl}`)
 		} catch (error) {
 			vscode.window.showErrorMessage(t("common:errors.hmr_not_running"))
-
 			return this.getHtmlContent(webview)
 		}
 
@@ -956,7 +1085,7 @@ export class ClineProvider
 	 * @param newMode The mode to switch to
 	 */
 	public async handleModeSwitch(newMode: Mode) {
-		const cline = this.getCurrentCline()
+		const cline = this.getCurrentTask()
 
 		if (cline) {
 			TelemetryService.instance.captureModeSwitch(cline.taskId, newMode)
@@ -1069,7 +1198,7 @@ export class ClineProvider
 
 				// Change the provider for the current task.
 				// TODO: We should rename `buildApiHandler` for clarity (e.g. `getProviderClient`).
-				const task = this.getCurrentCline()
+				const task = this.getCurrentTask()
 
 				if (task) {
 					task.api = buildApiHandler(providerSettings)
@@ -1130,7 +1259,7 @@ export class ClineProvider
 		}
 
 		// Change the provider for the current task.
-		const task = this.getCurrentCline()
+		const task = this.getCurrentTask()
 
 		if (task) {
 			task.api = buildApiHandler(providerSettings)
@@ -1142,7 +1271,7 @@ export class ClineProvider
 	// Task Management
 
 	async cancelTask() {
-		const cline = this.getCurrentCline()
+		const cline = this.getCurrentTask()
 
 		if (!cline) {
 			return
@@ -1159,13 +1288,13 @@ export class ClineProvider
 
 		await pWaitFor(
 			() =>
-				this.getCurrentCline()! === undefined ||
-				this.getCurrentCline()!.isStreaming === false ||
-				this.getCurrentCline()!.didFinishAbortingStream ||
+				this.getCurrentTask()! === undefined ||
+				this.getCurrentTask()!.isStreaming === false ||
+				this.getCurrentTask()!.didFinishAbortingStream ||
 				// If only the first chunk is processed, then there's no
 				// need to wait for graceful abort (closes edits, browser,
 				// etc).
-				this.getCurrentCline()!.isWaitingForFirstChunk,
+				this.getCurrentTask()!.isWaitingForFirstChunk,
 			{
 				timeout: 3_000,
 			},
@@ -1173,15 +1302,15 @@ export class ClineProvider
 			console.error("Failed to abort task")
 		})
 
-		if (this.getCurrentCline()) {
+		if (this.getCurrentTask()) {
 			// 'abandoned' will prevent this Cline instance from affecting
 			// future Cline instances. This may happen if its hanging on a
 			// streaming request.
-			this.getCurrentCline()!.abandoned = true
+			this.getCurrentTask()!.abandoned = true
 		}
 
 		// Clears task again, so we need to abortTask manually above.
-		await this.initClineWithHistoryItem({ ...historyItem, rootTask, parentTask })
+		await this.createTaskWithHistoryItem({ ...historyItem, rootTask, parentTask })
 	}
 
 	async updateCustomInstructions(instructions?: string) {
@@ -1339,10 +1468,10 @@ export class ClineProvider
 	}
 
 	async showTaskWithId(id: string) {
-		if (id !== this.getCurrentCline()?.taskId) {
+		if (id !== this.getCurrentTask()?.taskId) {
 			// Non-current task.
 			const { historyItem } = await this.getTaskWithId(id)
-			await this.initClineWithHistoryItem(historyItem) // Clears existing task.
+			await this.createTaskWithHistoryItem(historyItem) // Clears existing task.
 		}
 
 		await this.postMessageToWebview({ type: "action", action: "chatButtonClicked" })
@@ -1376,7 +1505,7 @@ export class ClineProvider
 			const { taskDirPath } = await this.getTaskWithId(id)
 
 			// remove task from stack if it's the current task
-			if (id === this.getCurrentCline()?.taskId) {
+			if (id === this.getCurrentTask()?.taskId) {
 				// if we found the taskid to delete - call finish to abort this task and allow a new task to be started,
 				// if we are deleting a subtask and parent task is still waiting for subtask to finish - it allows the parent to resume (this case should neve exist)
 				await this.finishSubTask(t("common:tasks.deleted"))
@@ -1421,6 +1550,7 @@ export class ClineProvider
 		const taskHistory = this.getGlobalState("taskHistory") ?? []
 		const updatedTaskHistory = taskHistory.filter((task) => task.id !== id)
 		await this.updateGlobalState("taskHistory", updatedTaskHistory)
+		this.recentTasksCache = undefined
 		await this.postStateToWebview()
 	}
 
@@ -1429,7 +1559,8 @@ export class ClineProvider
 		this.postMessageToWebview({ type: "state", state })
 
 		// Check MDM compliance and send user to account tab if not compliant
-		if (!this.checkMdmCompliance()) {
+		// Only redirect if there's an actual MDM policy requiring authentication
+		if (this.mdmService?.requiresCloudAuth() && !this.checkMdmCompliance()) {
 			await this.postMessageToWebview({ type: "action", action: "accountButtonClicked" })
 		}
 	}
@@ -1629,6 +1760,7 @@ export class ClineProvider
 			includeDiagnosticMessages,
 			maxDiagnosticMessages,
 			includeTaskHistoryInEnhance,
+			remoteControlEnabled,
 		} = await this.getState()
 
 		const telemetryKey = process.env.POSTHOG_API_KEY
@@ -1661,10 +1793,11 @@ export class ClineProvider
 			autoCondenseContext: autoCondenseContext ?? true,
 			autoCondenseContextPercent: autoCondenseContextPercent ?? 100,
 			uriScheme: vscode.env.uriScheme,
-			currentTaskItem: this.getCurrentCline()?.taskId
-				? (taskHistory || []).find((item: HistoryItem) => item.id === this.getCurrentCline()?.taskId)
+			currentTaskItem: this.getCurrentTask()?.taskId
+				? (taskHistory || []).find((item: HistoryItem) => item.id === this.getCurrentTask()?.taskId)
 				: undefined,
-			clineMessages: this.getCurrentCline()?.clineMessages || [],
+			clineMessages: this.getCurrentTask()?.clineMessages || [],
+			currentTaskTodos: this.getCurrentTask()?.todoList || [],
 			taskHistory: (taskHistory || [])
 				.filter((item: HistoryItem) => item.ts && item.task)
 				.sort((a: HistoryItem, b: HistoryItem) => b.ts - a.ts),
@@ -1747,7 +1880,9 @@ export class ClineProvider
 				codebaseIndexSearchMaxResults: codebaseIndexConfig?.codebaseIndexSearchMaxResults,
 				codebaseIndexSearchMinScore: codebaseIndexConfig?.codebaseIndexSearchMinScore,
 			},
-			mdmCompliant: this.checkMdmCompliance(),
+			// Only set mdmCompliant if there's an actual MDM policy
+			// undefined means no MDM policy, true means compliant, false means non-compliant
+			mdmCompliant: this.mdmService?.requiresCloudAuth() ? this.checkMdmCompliance() : undefined,
 			profileThresholds: profileThresholds ?? {},
 			cloudApiUrl: getRooCodeApiUrl(),
 			hasOpenedModeSelector: this.getGlobalState("hasOpenedModeSelector") ?? false,
@@ -1755,7 +1890,8 @@ export class ClineProvider
 			followupAutoApproveTimeoutMs: followupAutoApproveTimeoutMs ?? 60000,
 			includeDiagnosticMessages: includeDiagnosticMessages ?? true,
 			maxDiagnosticMessages: maxDiagnosticMessages ?? 50,
-			includeTaskHistoryInEnhance: includeTaskHistoryInEnhance ?? false,
+			includeTaskHistoryInEnhance: includeTaskHistoryInEnhance ?? true,
+			remoteControlEnabled: remoteControlEnabled ?? false,
 		}
 	}
 
@@ -1942,7 +2078,9 @@ export class ClineProvider
 			includeDiagnosticMessages: stateValues.includeDiagnosticMessages ?? true,
 			maxDiagnosticMessages: stateValues.maxDiagnosticMessages ?? 50,
 			// Add includeTaskHistoryInEnhance setting
-			includeTaskHistoryInEnhance: stateValues.includeTaskHistoryInEnhance ?? false,
+			includeTaskHistoryInEnhance: stateValues.includeTaskHistoryInEnhance ?? true,
+			// Add remoteControlEnabled setting
+			remoteControlEnabled: stateValues.remoteControlEnabled ?? false,
 		}
 	}
 
@@ -1957,6 +2095,8 @@ export class ClineProvider
 		}
 
 		await this.updateGlobalState("taskHistory", history)
+		this.recentTasksCache = undefined
+
 		return history
 	}
 
@@ -2022,24 +2162,27 @@ export class ClineProvider
 		console.log(message)
 	}
 
-	// integration tests
+	// getters
+
+	public get workspaceTracker(): WorkspaceTracker | undefined {
+		return this._workspaceTracker
+	}
 
 	get viewLaunched() {
 		return this.isViewLaunched
 	}
 
 	get messages() {
-		return this.getCurrentCline()?.clineMessages || []
+		return this.getCurrentTask()?.clineMessages || []
 	}
 
-	// Add public getter
 	public getMcpHub(): McpHub | undefined {
 		return this.mcpHub
 	}
 
 	/**
 	 * Check if the current state is compliant with MDM policy
-	 * @returns true if compliant, false if blocked
+	 * @returns true if compliant or no MDM policy exists, false if MDM policy exists and user is non-compliant
 	 */
 	public checkMdmCompliance(): boolean {
 		if (!this.mdmService) {
@@ -2055,18 +2198,82 @@ export class ClineProvider
 		return true
 	}
 
-	/**
-	 * Returns properties to be included in every telemetry event
-	 * This method is called by the telemetry service to get context information
-	 * like the current mode, API provider, git repository information, etc.
-	 */
-	public async getTelemetryProperties(): Promise<TelemetryProperties> {
-		const { mode, apiConfiguration, language } = await this.getState()
-		const task = this.getCurrentCline()
+	public async handleRemoteControlToggle(enabled: boolean) {
+		const { CloudService: CloudServiceImport, ExtensionBridgeService } = await import("@roo-code/cloud")
+
+		const userInfo = CloudServiceImport.instance.getUserInfo()
+
+		const bridgeConfig = await CloudServiceImport.instance.cloudAPI?.bridgeConfig().catch(() => undefined)
+
+		if (!bridgeConfig) {
+			this.log("[ClineProvider#handleRemoteControlToggle] Failed to get bridge config")
+			return
+		}
+
+		await ExtensionBridgeService.handleRemoteControlState(
+			userInfo,
+			enabled,
+			{ ...bridgeConfig, provider: this, sessionId: vscode.env.sessionId },
+			(message: string) => this.log(message),
+		)
+
+		if (isRemoteControlEnabled(userInfo, enabled)) {
+			const currentTask = this.getCurrentTask()
+
+			if (currentTask && !currentTask.bridgeService) {
+				try {
+					currentTask.bridgeService = ExtensionBridgeService.getInstance()
+
+					if (currentTask.bridgeService) {
+						await currentTask.bridgeService.subscribeToTask(currentTask)
+					}
+				} catch (error) {
+					const message = `[ClineProvider#handleRemoteControlToggle] subscribeToTask failed - ${error instanceof Error ? error.message : String(error)}`
+					this.log(message)
+					console.error(message)
+				}
+			}
+		} else {
+			for (const task of this.clineStack) {
+				if (task.bridgeService) {
+					try {
+						await task.bridgeService.unsubscribeFromTask(task.taskId)
+						task.bridgeService = null
+					} catch (error) {
+						const message = `[ClineProvider#handleRemoteControlToggle] unsubscribeFromTask failed - ${error instanceof Error ? error.message : String(error)}`
+						this.log(message)
+						console.error(message)
+					}
+				}
+			}
+
+			ExtensionBridgeService.resetInstance()
+		}
+	}
+
+	private _appProperties?: StaticAppProperties
+
+	private getAppProperties(): StaticAppProperties {
+		if (!this._appProperties) {
+			const packageJSON = this.context.extension?.packageJSON
+
+			this._appProperties = {
+				appName: packageJSON?.name ?? Package.name,
+				appVersion: packageJSON?.version ?? Package.version,
+				vscodeVersion: vscode.version,
+				platform: process.platform,
+				editorName: vscode.env.appName,
+			}
+		}
+
+		return this._appProperties
+	}
 
-		const packageJSON = this.context.extension?.packageJSON
+	public get appProperties(): StaticAppProperties {
+		return this._appProperties ?? this.getAppProperties()
+	}
 
-		// Get Roo Code Cloud authentication state
+	private getCloudProperties(): CloudAppProperties {
 		let cloudIsAuthenticated: boolean | undefined
 
 		try {
@@ -2074,14 +2281,19 @@ export class ClineProvider
 				cloudIsAuthenticated = CloudService.instance.isAuthenticated()
 			}
 		} catch (error) {
-			// Silently handle errors to avoid breaking telemetry collection
+			// Silently handle errors to avoid breaking telemetry collection.
 			this.log(`[getTelemetryProperties] Failed to get cloud auth state: ${error}`)
 		}
 
-		// Get git repository information
-		const gitInfo = await getWorkspaceGitInfo()
+		return {
+			cloudIsAuthenticated,
+		}
+	}
+
+	private async getTaskProperties(): Promise<DynamicAppProperties & TaskProperties> {
+		const { language, mode, apiConfiguration } = await this.getState()
 
-		// Calculate todo list statistics
+		const task = this.getCurrentTask()
 		const todoList = task?.todoList
 		let todos: { total: number; completed: number; inProgress: number; pending: number } | undefined
 
@@ -2094,22 +2306,38 @@ export class ClineProvider
 			}
 		}
 
-		// Return all properties including git info - clients will filter as needed
 		return {
-			appName: packageJSON?.name ?? Package.name,
-			appVersion: packageJSON?.version ?? Package.version,
-			vscodeVersion: vscode.version,
-			platform: process.platform,
-			editorName: vscode.env.appName,
 			language,
 			mode,
+			taskId: task?.taskId,
 			apiProvider: apiConfiguration?.apiProvider,
 			modelId: task?.api?.getModel().id,
 			diffStrategy: task?.diffStrategy?.getName(),
 			isSubtask: task ? !!task.parentTask : undefined,
-			cloudIsAuthenticated,
 			...(todos && { todos }),
-			...gitInfo,
+		}
+	}
+
+	private _gitProperties?: GitProperties
+
+	private async getGitProperties(): Promise<GitProperties> {
+		if (!this._gitProperties) {
+			this._gitProperties = await getWorkspaceGitInfo()
+		}
+
+		return this._gitProperties
+	}
+
+	public get gitProperties(): GitProperties | undefined {
+		return this._gitProperties
+	}
+
+	public async getTelemetryProperties(): Promise<TelemetryProperties> {
+		return {
+			...this.getAppProperties(),
+			...this.getCloudProperties(),
+			...(await this.getTaskProperties()),
+			...(await this.getGitProperties()),
 		}
 	}
 
