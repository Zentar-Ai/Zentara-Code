import { describe, it, expect, beforeEach, vi } from "vitest"
import { Task } from "../Task"
import type { ClineMessage } from "@roo-code/types"

// Mock dependencies
vi.mock("../../../api", () => ({
	buildApiHandler: vi.fn().mockReturnValue({
		createMessageStream: vi.fn(),
	}),
}))

vi.mock("../../webview/ClineProvider", () => ({
	ClineProvider: vi.fn().mockImplementation(() => ({
		postStateToWebview: vi.fn(),
		queueAskRequest: vi.fn(),
		removeFromAskQueue: vi.fn(),
		log: vi.fn(),
	})),
}))

vi.mock("../task-persistence/messages", () => ({
	readTaskMessages: vi.fn().mockResolvedValue([]),
	saveTaskMessages: vi.fn().mockResolvedValue(undefined),
}))

vi.mock("../task-persistence/metadata", () => ({
	taskMetadata: vi.fn().mockResolvedValue({
		historyItem: {},
		tokenUsage: {},
	}),
}))

vi.mock("../../services/telemetry/CloudService", () => ({
	CloudService: {
		isEnabled: vi.fn().mockReturnValue(false),
		saveCapturedData: vi.fn(),
	},
}))

describe("Task.addToClineMessages", () => {
	let task: Task
	let mockProvider: any

	beforeEach(() => {
		vi.clearAllMocks()

		mockProvider = {
			postStateToWebview: vi.fn().mockResolvedValue(undefined),
			queueAskRequest: vi.fn().mockResolvedValue(undefined),
			removeFromAskQueue: vi.fn(),
			log: vi.fn(),
		}

		task = new Task({
			taskId: "test-task-456",
			instanceId: "instance-1",
			providerRef: new WeakRef(mockProvider),
			context: {} as any,
			api: {} as any,
			mode: "default",
			customInstructions: "",
			alwaysAllowReadOnly: false,
			alwaysAllowReadOnlyOutsideWorkspace: false,
			alwaysAllowWrite: false,
			alwaysAllowWriteOutsideWorkspace: false,
			alwaysAllowWriteProtected: false,
			alwaysAllowExecute: false,
			alwaysAllowBrowser: false,
			alwaysAllowMcp: false,
			alwaysAllowDebug: false,
			allowedCommands: [],
			browserViewport: { width: 1280, height: 800 },
			screenshotQuality: "high",
			mcpHub: {} as any,
			cwd: "/test",
			task: "Test task",
			baseDirectory: "/test",
			filePaths: [],
			openedTabs: [],
			globalStoragePath: "/storage",
			apiKey: "test-key",
			maxAutomaticRequestsPerTask: 5,
			maxRequestsPerTask: 10,
			profileThresholds: {},
		})
	})

	describe("taskId inclusion", () => {
		it("should add taskId to say messages", async () => {
			const sayText = "Hello from task"
			await task.say("text", sayText)

			const messages = task.clineMessages
			expect(messages).toHaveLength(1)

			const message = messages[0]
			expect(message.taskId).toBe("test-task-456")
			expect(message.type).toBe("say")
			expect(message.text).toBe(sayText)
		})

		it("should add taskId to ask messages", async () => {
			// Start ask operation (don't await yet)
			const askPromise = task.ask("tool", "Approve file read?")

			// Check that message was added with taskId
			const messages = task.clineMessages
			expect(messages).toHaveLength(1)

			const message = messages[0]
			expect(message.taskId).toBe("test-task-456")
			expect(message.type).toBe("ask")
			expect(message.ask).toBe("tool")
			expect(message.text).toBe("Approve file read?")

			// Simulate response
			task.handleWebviewAskResponse("yesButtonClicked")
			await askPromise
		})

		it("should preserve all original message properties", async () => {
			const originalMessage: ClineMessage = {
				ts: Date.now(),
				type: "say",
				say: "user_feedback",
				text: "Complex message",
				images: ["image1.png", "image2.png"],
				partial: true,
			}

			// Access private method through type assertion
			await (task as any).addToClineMessages(originalMessage)

			const messages = task.clineMessages
			expect(messages).toHaveLength(1)

			const savedMessage = messages[0]
			expect(savedMessage).toMatchObject({
				...originalMessage,
				taskId: "test-task-456",
			})
			expect(savedMessage.images).toEqual(["image1.png", "image2.png"])
			expect(savedMessage.partial).toBe(true)
		})

		it("should override existing taskId if message already has one", async () => {
			const messageWithWrongTaskId: ClineMessage = {
				ts: Date.now(),
				type: "say",
				say: "text",
				text: "Message with wrong task ID",
				taskId: "wrong-task-id",
			}

			await (task as any).addToClineMessages(messageWithWrongTaskId)

			const messages = task.clineMessages
			expect(messages).toHaveLength(1)
			expect(messages[0].taskId).toBe("test-task-456") // Should use task's ID
		})
	})

	describe("provider interactions", () => {
		it("should call postStateToWebview after adding message", async () => {
			await task.say("text", "Test message")

			expect(mockProvider.postStateToWebview).toHaveBeenCalledTimes(1)
		})

		it("should queue ask request for ask messages", async () => {
			const askPromise = task.ask("tool", "Approve?")

			expect(mockProvider.queueAskRequest).toHaveBeenCalledWith(task)
			expect(mockProvider.queueAskRequest).toHaveBeenCalledTimes(1)

			// Cleanup
			task.handleWebviewAskResponse("yesButtonClicked")
			await askPromise
		})

		it("should not queue ask request for say messages", async () => {
			await task.say("text", "Just saying")

			expect(mockProvider.queueAskRequest).not.toHaveBeenCalled()
		})

		it("should handle missing provider gracefully", async () => {
			// Create task with no provider
			const orphanTask = (new Task({
				...task.options,
				providerRef: new WeakRef({} as any), // Empty object that will be garbage collected
			} as any)(
				// Force provider to be undefined
				orphanTask as any,
			).providerRef = new WeakRef(undefined as any))

			// Should not throw
			await expect(orphanTask.say("text", "No provider")).resolves.not.toThrow()

			// Message should still be added
			expect(orphanTask.clineMessages).toHaveLength(1)
			expect(orphanTask.clineMessages[0].taskId).toBe(orphanTask.taskId)
		})
	})

	describe("CloudService integration", () => {
		beforeEach(() => {
			const { CloudService } = vi.mocked(await import("../../services/telemetry/CloudService"))
			CloudService.isEnabled.mockReturnValue(true)
		})

		it("should capture non-partial messages when CloudService is enabled", async () => {
			const { CloudService } = vi.mocked(await import("../../services/telemetry/CloudService"))

			await task.say("text", "Captured message")

			expect(CloudService.saveCapturedData).toHaveBeenCalledWith(
				expect.objectContaining({
					messages: expect.arrayContaining([
						expect.objectContaining({
							taskId: "test-task-456",
							text: "Captured message",
						}),
					]),
				}),
			)
		})

		it("should not capture partial messages", async () => {
			const { CloudService } = vi.mocked(await import("../../services/telemetry/CloudService"))

			const partialMessage: ClineMessage = {
				ts: Date.now(),
				type: "say",
				say: "text",
				text: "Partial message",
				partial: true,
			}

			await (task as any).addToClineMessages(partialMessage)

			expect(CloudService.saveCapturedData).not.toHaveBeenCalled()
		})

		it("should not capture when CloudService is disabled", async () => {
			const { CloudService } = vi.mocked(await import("../../services/telemetry/CloudService"))
			CloudService.isEnabled.mockReturnValue(false)

			await task.say("text", "Not captured")

			expect(CloudService.saveCapturedData).not.toHaveBeenCalled()
		})
	})

	describe("message persistence", () => {
		it("should trigger save after adding messages", async () => {
			const { saveTaskMessages } = vi.mocked(await import("../task-persistence/messages"))

			await task.say("text", "Message to save")

			// Save happens asynchronously
			await new Promise((resolve) => setTimeout(resolve, 100))

			expect(saveTaskMessages).toHaveBeenCalledWith(
				expect.objectContaining({
					taskId: "test-task-456",
					messages: expect.arrayContaining([
						expect.objectContaining({
							taskId: "test-task-456",
							text: "Message to save",
						}),
					]),
				}),
			)
		})
	})
})
